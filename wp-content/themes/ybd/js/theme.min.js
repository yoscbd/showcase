/*!
  * Understrap v1.1.0 (https://understrap.com)
  * Copyright 2013-2022 The UnderStrap Authors (https://github.com/understrap/understrap/graphs/contributors)
  * Licensed under GPL (http://www.gnu.org/licenses/old-licenses/gpl-2.0.en.html)
  */
!function (t, e) { "object" == typeof exports && "undefined" != typeof module ? e(exports, require("jquery")) : "function" == typeof define && define.amd ? define(["exports", "jquery"], e) : e((t = "undefined" != typeof globalThis ? globalThis : t || self).understrap = {}, t.jQuery) }(this, (function (t, e) {
	"use strict"; function n(t) { return t && "object" == typeof t && "default" in t ? t : { default: t } } var i = n(e); "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self && self; function s(t) { return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t } function o(t) { if (t.__esModule) return t; var e = Object.defineProperty({}, "__esModule", { value: !0 }); return Object.keys(t).forEach((function (n) { var i = Object.getOwnPropertyDescriptor(t, n); Object.defineProperty(e, n, i.get ? i : { enumerable: !0, get: function () { return t[n] } }) })), e } var r = { exports: {} }, a = { exports: {} };
	/*!
		  * Bootstrap event-handler.js v5.1.3 (https://getbootstrap.com/)
		  * Copyright 2011-2021 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
		  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
		  */
	!function (t, e) { t.exports = function () { const t = () => { const { jQuery: t } = window; return t && !document.body.hasAttribute("data-bs-no-jquery") ? t : null }, e = /[^.]*(?=\..*)\.|.*/, n = /\..*/, i = /::\d+$/, s = {}; let o = 1; const r = { mouseenter: "mouseover", mouseleave: "mouseout" }, a = /^(mouseenter|mouseleave)/i, l = new Set(["click", "dblclick", "mouseup", "mousedown", "contextmenu", "mousewheel", "DOMMouseScroll", "mouseover", "mouseout", "mousemove", "selectstart", "selectend", "keydown", "keypress", "keyup", "orientationchange", "touchstart", "touchmove", "touchend", "touchcancel", "pointerdown", "pointermove", "pointerup", "pointerleave", "pointercancel", "gesturestart", "gesturechange", "gestureend", "focus", "blur", "change", "reset", "select", "submit", "focusin", "focusout", "load", "unload", "beforeunload", "resize", "move", "DOMContentLoaded", "readystatechange", "error", "abort", "scroll"]); function c(t, e) { return e && `${e}::${o++}` || t.uidEvent || o++ } function d(t) { const e = c(t); return t.uidEvent = e, s[e] = s[e] || {}, s[e] } function u(t, e) { return function n(i) { return i.delegateTarget = t, n.oneOff && v.off(t, i.type, e), e.apply(t, [i]) } } function f(t, e, n) { return function i(s) { const o = t.querySelectorAll(e); for (let { target: r } = s; r && r !== this; r = r.parentNode)for (let a = o.length; a--;)if (o[a] === r) return s.delegateTarget = r, i.oneOff && v.off(t, s.type, e, n), n.apply(r, [s]); return null } } function h(t, e, n = null) { const i = Object.keys(t); for (let s = 0, o = i.length; s < o; s++) { const o = t[i[s]]; if (o.originalHandler === e && o.delegationSelector === n) return o } return null } function p(t, e, n) { const i = "string" == typeof e, s = i ? n : e; let o = b(t); return l.has(o) || (o = t), [i, s, o] } function m(t, n, i, s, o) { if ("string" != typeof n || !t) return; if (i || (i = s, s = null), a.test(n)) { const t = t => function (e) { if (!e.relatedTarget || e.relatedTarget !== e.delegateTarget && !e.delegateTarget.contains(e.relatedTarget)) return t.call(this, e) }; s ? s = t(s) : i = t(i) } const [r, l, m] = p(n, i, s), g = d(t), _ = g[m] || (g[m] = {}), b = h(_, l, r ? i : null); if (b) return void (b.oneOff = b.oneOff && o); const v = c(l, n.replace(e, "")), y = r ? f(t, i, s) : u(t, i); y.delegationSelector = r ? i : null, y.originalHandler = l, y.oneOff = o, y.uidEvent = v, _[v] = y, t.addEventListener(m, y, r) } function g(t, e, n, i, s) { const o = h(e[n], i, s); o && (t.removeEventListener(n, o, Boolean(s)), delete e[n][o.uidEvent]) } function _(t, e, n, i) { const s = e[n] || {}; Object.keys(s).forEach((o => { if (o.includes(i)) { const i = s[o]; g(t, e, n, i.originalHandler, i.delegationSelector) } })) } function b(t) { return t = t.replace(n, ""), r[t] || t } const v = { on(t, e, n, i) { m(t, e, n, i, !1) }, one(t, e, n, i) { m(t, e, n, i, !0) }, off(t, e, n, s) { if ("string" != typeof e || !t) return; const [o, r, a] = p(e, n, s), l = a !== e, c = d(t), u = e.startsWith("."); if (void 0 !== r) { if (!c || !c[a]) return; return void g(t, c, a, r, o ? n : null) } u && Object.keys(c).forEach((n => { _(t, c, n, e.slice(1)) })); const f = c[a] || {}; Object.keys(f).forEach((n => { const s = n.replace(i, ""); if (!l || e.includes(s)) { const e = f[n]; g(t, c, a, e.originalHandler, e.delegationSelector) } })) }, trigger(e, n, i) { if ("string" != typeof n || !e) return null; const s = t(), o = b(n), r = n !== o, a = l.has(o); let c, d = !0, u = !0, f = !1, h = null; return r && s && (c = s.Event(n, i), s(e).trigger(c), d = !c.isPropagationStopped(), u = !c.isImmediatePropagationStopped(), f = c.isDefaultPrevented()), a ? (h = document.createEvent("HTMLEvents"), h.initEvent(o, d, !0)) : h = new CustomEvent(n, { bubbles: d, cancelable: !0 }), void 0 !== i && Object.keys(i).forEach((t => { Object.defineProperty(h, t, { get: () => i[t] }) })), f && h.preventDefault(), u && e.dispatchEvent(h), h.defaultPrevented && void 0 !== c && c.preventDefault(), h } }; return v }() }(a); var l = { exports: {} }, c = { exports: {} };
	/*!
		  * Bootstrap data.js v5.1.3 (https://getbootstrap.com/)
		  * Copyright 2011-2021 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
		  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
		  */
	!function (t, e) { t.exports = function () { const t = new Map; return { set(e, n, i) { t.has(e) || t.set(e, new Map); const s = t.get(e); s.has(n) || 0 === s.size ? s.set(n, i) : console.error(`Bootstrap doesn't allow more than one instance per element. Bound instance: ${Array.from(s.keys())[0]}.`) }, get: (e, n) => t.has(e) && t.get(e).get(n) || null, remove(e, n) { if (!t.has(e)) return; const i = t.get(e); i.delete(n), 0 === i.size && t.delete(e) } } }() }(c),
		/*!
			  * Bootstrap base-component.js v5.1.3 (https://getbootstrap.com/)
			  * Copyright 2011-2021 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
			  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
			  */
		function (t, e) { t.exports = function (t, e) { const n = t => t && "object" == typeof t && "default" in t ? t : { default: t }, i = n(t), s = n(e), o = 1e3, r = "transitionend", a = t => { if (!t) return 0; let { transitionDuration: e, transitionDelay: n } = window.getComputedStyle(t); const i = Number.parseFloat(e), s = Number.parseFloat(n); return i || s ? (e = e.split(",")[0], n = n.split(",")[0], (Number.parseFloat(e) + Number.parseFloat(n)) * o) : 0 }, l = t => { t.dispatchEvent(new Event(r)) }, c = t => !(!t || "object" != typeof t) && (void 0 !== t.jquery && (t = t[0]), void 0 !== t.nodeType), d = t => c(t) ? t.jquery ? t[0] : t : "string" == typeof t && t.length > 0 ? document.querySelector(t) : null, u = t => { "function" == typeof t && t() }, f = (t, e, n = !0) => { if (!n) return void u(t); const i = 5, s = a(e) + i; let o = !1; const c = ({ target: n }) => { n === e && (o = !0, e.removeEventListener(r, c), u(t)) }; e.addEventListener(r, c), setTimeout((() => { o || l(e) }), s) }, h = "5.1.3"; class p { constructor(t) { (t = d(t)) && (this._element = t, i.default.set(this._element, this.constructor.DATA_KEY, this)) } dispose() { i.default.remove(this._element, this.constructor.DATA_KEY), s.default.off(this._element, this.constructor.EVENT_KEY), Object.getOwnPropertyNames(this).forEach((t => { this[t] = null })) } _queueCallback(t, e, n = !0) { f(t, e, n) } static getInstance(t) { return i.default.get(d(t), this.DATA_KEY) } static getOrCreateInstance(t, e = {}) { return this.getInstance(t) || new this(t, "object" == typeof e ? e : null) } static get VERSION() { return h } static get NAME() { throw new Error('You have to implement the static method "NAME", for each component!') } static get DATA_KEY() { return `bs.${this.NAME}` } static get EVENT_KEY() { return `.${this.DATA_KEY}` } } return p }(c.exports, a.exports) }(l),
		/*!
			  * Bootstrap alert.js v5.1.3 (https://getbootstrap.com/)
			  * Copyright 2011-2021 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
			  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
			  */
		function (t, e) { t.exports = function (t, e) { const n = t => t && "object" == typeof t && "default" in t ? t : { default: t }, i = n(t), s = n(e), o = t => { let e = t.getAttribute("data-bs-target"); if (!e || "#" === e) { let n = t.getAttribute("href"); if (!n || !n.includes("#") && !n.startsWith(".")) return null; n.includes("#") && !n.startsWith("#") && (n = `#${n.split("#")[1]}`), e = n && "#" !== n ? n.trim() : null } return e }, r = t => { const e = o(t); return e ? document.querySelector(e) : null }, a = t => !t || t.nodeType !== Node.ELEMENT_NODE || !!t.classList.contains("disabled") || (void 0 !== t.disabled ? t.disabled : t.hasAttribute("disabled") && "false" !== t.getAttribute("disabled")), l = () => { const { jQuery: t } = window; return t && !document.body.hasAttribute("data-bs-no-jquery") ? t : null }, c = [], d = t => { "loading" === document.readyState ? (c.length || document.addEventListener("DOMContentLoaded", (() => { c.forEach((t => t())) })), c.push(t)) : t() }, u = t => { d((() => { const e = l(); if (e) { const n = t.NAME, i = e.fn[n]; e.fn[n] = t.jQueryInterface, e.fn[n].Constructor = t, e.fn[n].noConflict = () => (e.fn[n] = i, t.jQueryInterface) } })) }, f = (t, e = "hide") => { const n = `click.dismiss${t.EVENT_KEY}`, s = t.NAME; i.default.on(document, n, `[data-bs-dismiss="${s}"]`, (function (n) { if (["A", "AREA"].includes(this.tagName) && n.preventDefault(), a(this)) return; const i = r(this) || this.closest(`.${s}`); t.getOrCreateInstance(i)[e]() })) }, h = "alert", p = ".bs.alert", m = `close${p}`, g = `closed${p}`, _ = "fade", b = "show"; class v extends s.default { static get NAME() { return h } close() { if (i.default.trigger(this._element, m).defaultPrevented) return; this._element.classList.remove(b); const t = this._element.classList.contains(_); this._queueCallback((() => this._destroyElement()), this._element, t) } _destroyElement() { this._element.remove(), i.default.trigger(this._element, g), this.dispose() } static jQueryInterface(t) { return this.each((function () { const e = v.getOrCreateInstance(this); if ("string" == typeof t) { if (void 0 === e[t] || t.startsWith("_") || "constructor" === t) throw new TypeError(`No method named "${t}"`); e[t](this) } })) } } return f(v, "close"), u(v), v }(a.exports, l.exports) }(r); var d = r.exports, u = { exports: {} };
	/*!
		  * Bootstrap button.js v5.1.3 (https://getbootstrap.com/)
		  * Copyright 2011-2021 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
		  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
		  */
	!function (t, e) { t.exports = function (t, e) { const n = t => t && "object" == typeof t && "default" in t ? t : { default: t }, i = n(t), s = n(e), o = () => { const { jQuery: t } = window; return t && !document.body.hasAttribute("data-bs-no-jquery") ? t : null }, r = [], a = t => { "loading" === document.readyState ? (r.length || document.addEventListener("DOMContentLoaded", (() => { r.forEach((t => t())) })), r.push(t)) : t() }, l = t => { a((() => { const e = o(); if (e) { const n = t.NAME, i = e.fn[n]; e.fn[n] = t.jQueryInterface, e.fn[n].Constructor = t, e.fn[n].noConflict = () => (e.fn[n] = i, t.jQueryInterface) } })) }, c = "button", d = "active", u = '[data-bs-toggle="button"]', f = "click.bs.button.data-api"; class h extends s.default { static get NAME() { return c } toggle() { this._element.setAttribute("aria-pressed", this._element.classList.toggle(d)) } static jQueryInterface(t) { return this.each((function () { const e = h.getOrCreateInstance(this); "toggle" === t && e[t]() })) } } return i.default.on(document, f, u, (t => { t.preventDefault(); const e = t.target.closest(u); h.getOrCreateInstance(e).toggle() })), l(h), h }(a.exports, l.exports) }(u); var f = u.exports, h = { exports: {} }, p = { exports: {} };
	/*!
		  * Bootstrap manipulator.js v5.1.3 (https://getbootstrap.com/)
		  * Copyright 2011-2021 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
		  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
		  */
	!function (t, e) { t.exports = function () { function t(t) { return "true" === t || "false" !== t && (t === Number(t).toString() ? Number(t) : "" === t || "null" === t ? null : t) } function e(t) { return t.replace(/[A-Z]/g, (t => `-${t.toLowerCase()}`)) } return { setDataAttribute(t, n, i) { t.setAttribute(`data-bs-${e(n)}`, i) }, removeDataAttribute(t, n) { t.removeAttribute(`data-bs-${e(n)}`) }, getDataAttributes(e) { if (!e) return {}; const n = {}; return Object.keys(e.dataset).filter((t => t.startsWith("bs"))).forEach((i => { let s = i.replace(/^bs/, ""); s = s.charAt(0).toLowerCase() + s.slice(1, s.length), n[s] = t(e.dataset[i]) })), n }, getDataAttribute: (n, i) => t(n.getAttribute(`data-bs-${e(i)}`)), offset(t) { const e = t.getBoundingClientRect(); return { top: e.top + window.pageYOffset, left: e.left + window.pageXOffset } }, position: t => ({ top: t.offsetTop, left: t.offsetLeft }) } }() }(p); var m = { exports: {} };
/*!
	  * Bootstrap selector-engine.js v5.1.3 (https://getbootstrap.com/)
	  * Copyright 2011-2021 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
	  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
	  */!function (t, e) { t.exports = function () { const t = t => !(!t || "object" != typeof t) && (void 0 !== t.jquery && (t = t[0]), void 0 !== t.nodeType), e = e => !(!t(e) || 0 === e.getClientRects().length) && "visible" === getComputedStyle(e).getPropertyValue("visibility"), n = t => !t || t.nodeType !== Node.ELEMENT_NODE || !!t.classList.contains("disabled") || (void 0 !== t.disabled ? t.disabled : t.hasAttribute("disabled") && "false" !== t.getAttribute("disabled")), i = 3; return { find: (t, e = document.documentElement) => [].concat(...Element.prototype.querySelectorAll.call(e, t)), findOne: (t, e = document.documentElement) => Element.prototype.querySelector.call(e, t), children: (t, e) => [].concat(...t.children).filter((t => t.matches(e))), parents(t, e) { const n = []; let s = t.parentNode; for (; s && s.nodeType === Node.ELEMENT_NODE && s.nodeType !== i;)s.matches(e) && n.push(s), s = s.parentNode; return n }, prev(t, e) { let n = t.previousElementSibling; for (; n;) { if (n.matches(e)) return [n]; n = n.previousElementSibling } return [] }, next(t, e) { let n = t.nextElementSibling; for (; n;) { if (n.matches(e)) return [n]; n = n.nextElementSibling } return [] }, focusableChildren(t) { const i = ["a", "button", "input", "textarea", "select", "details", "[tabindex]", '[contenteditable="true"]'].map((t => `${t}:not([tabindex^="-"])`)).join(", "); return this.find(i, t).filter((t => !n(t) && e(t))) } } }() }(m),
		/*!
			  * Bootstrap carousel.js v5.1.3 (https://getbootstrap.com/)
			  * Copyright 2011-2021 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
			  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
			  */
		function (t, e) { t.exports = function (t, e, n, i) { const s = t => t && "object" == typeof t && "default" in t ? t : { default: t }, o = s(t), r = s(e), a = s(n), l = s(i), c = "transitionend", d = t => null == t ? `${t}` : {}.toString.call(t).match(/\s([a-z]+)/i)[1].toLowerCase(), u = t => { let e = t.getAttribute("data-bs-target"); if (!e || "#" === e) { let n = t.getAttribute("href"); if (!n || !n.includes("#") && !n.startsWith(".")) return null; n.includes("#") && !n.startsWith("#") && (n = `#${n.split("#")[1]}`), e = n && "#" !== n ? n.trim() : null } return e }, f = t => { const e = u(t); return e ? document.querySelector(e) : null }, h = t => { t.dispatchEvent(new Event(c)) }, p = t => !(!t || "object" != typeof t) && (void 0 !== t.jquery && (t = t[0]), void 0 !== t.nodeType), m = (t, e, n) => { Object.keys(n).forEach((i => { const s = n[i], o = e[i], r = o && p(o) ? "element" : d(o); if (!new RegExp(s).test(r)) throw new TypeError(`${t.toUpperCase()}: Option "${i}" provided type "${r}" but expected type "${s}".`) })) }, g = t => !(!p(t) || 0 === t.getClientRects().length) && "visible" === getComputedStyle(t).getPropertyValue("visibility"), _ = t => { t.offsetHeight }, b = () => { const { jQuery: t } = window; return t && !document.body.hasAttribute("data-bs-no-jquery") ? t : null }, v = [], y = t => { "loading" === document.readyState ? (v.length || document.addEventListener("DOMContentLoaded", (() => { v.forEach((t => t())) })), v.push(t)) : t() }, w = () => "rtl" === document.documentElement.dir, E = t => { y((() => { const e = b(); if (e) { const n = t.NAME, i = e.fn[n]; e.fn[n] = t.jQueryInterface, e.fn[n].Constructor = t, e.fn[n].noConflict = () => (e.fn[n] = i, t.jQueryInterface) } })) }, A = (t, e, n, i) => { let s = t.indexOf(e); if (-1 === s) return t[!n && i ? t.length - 1 : 0]; const o = t.length; return s += n ? 1 : -1, i && (s = (s + o) % o), t[Math.max(0, Math.min(s, o - 1))] }, x = "carousel", C = ".bs.carousel", O = ".data-api", T = 500, k = 40, L = { interval: 5e3, keyboard: !0, slide: !1, pause: "hover", wrap: !0, touch: !0 }, j = { interval: "(number|boolean)", keyboard: "boolean", slide: "(boolean|string)", pause: "(string|boolean)", wrap: "boolean", touch: "boolean" }, $ = "next", N = "prev", D = "left", S = "right", I = { ArrowLeft: S, ArrowRight: D }, M = `slide${C}`, P = `slid${C}`, q = `keydown${C}`, R = `mouseenter${C}`, W = `mouseleave${C}`, H = `touchstart${C}`, B = `touchmove${C}`, z = `touchend${C}`, Q = `pointerdown${C}`, F = `pointerup${C}`, V = `dragstart${C}`, U = `load${C}${O}`, K = `click${C}${O}`, X = "carousel", Y = "active", G = "slide", Z = "carousel-item-end", J = "carousel-item-start", tt = "carousel-item-next", et = "carousel-item-prev", nt = "pointer-event", it = ".active", st = ".active.carousel-item", ot = ".carousel-item", rt = ".carousel-item img", at = ".carousel-item-next, .carousel-item-prev", lt = ".carousel-indicators", ct = "[data-bs-target]", dt = "[data-bs-slide], [data-bs-slide-to]", ut = '[data-bs-ride="carousel"]', ft = "touch", ht = "pen"; class pt extends l.default { constructor(t, e) { super(t), this._items = null, this._interval = null, this._activeElement = null, this._isPaused = !1, this._isSliding = !1, this.touchTimeout = null, this.touchStartX = 0, this.touchDeltaX = 0, this._config = this._getConfig(e), this._indicatorsElement = a.default.findOne(lt, this._element), this._touchSupported = "ontouchstart" in document.documentElement || navigator.maxTouchPoints > 0, this._pointerEvent = Boolean(window.PointerEvent), this._addEventListeners() } static get Default() { return L } static get NAME() { return x } next() { this._slide($) } nextWhenVisible() { !document.hidden && g(this._element) && this.next() } prev() { this._slide(N) } pause(t) { t || (this._isPaused = !0), a.default.findOne(at, this._element) && (h(this._element), this.cycle(!0)), clearInterval(this._interval), this._interval = null } cycle(t) { t || (this._isPaused = !1), this._interval && (clearInterval(this._interval), this._interval = null), this._config && this._config.interval && !this._isPaused && (this._updateInterval(), this._interval = setInterval((document.visibilityState ? this.nextWhenVisible : this.next).bind(this), this._config.interval)) } to(t) { this._activeElement = a.default.findOne(st, this._element); const e = this._getItemIndex(this._activeElement); if (t > this._items.length - 1 || t < 0) return; if (this._isSliding) return void o.default.one(this._element, P, (() => this.to(t))); if (e === t) return this.pause(), void this.cycle(); const n = t > e ? $ : N; this._slide(n, this._items[t]) } _getConfig(t) { return t = { ...L, ...r.default.getDataAttributes(this._element), ..."object" == typeof t ? t : {} }, m(x, t, j), t } _handleSwipe() { const t = Math.abs(this.touchDeltaX); if (t <= k) return; const e = t / this.touchDeltaX; this.touchDeltaX = 0, e && this._slide(e > 0 ? S : D) } _addEventListeners() { this._config.keyboard && o.default.on(this._element, q, (t => this._keydown(t))), "hover" === this._config.pause && (o.default.on(this._element, R, (t => this.pause(t))), o.default.on(this._element, W, (t => this.cycle(t)))), this._config.touch && this._touchSupported && this._addTouchEventListeners() } _addTouchEventListeners() { const t = t => this._pointerEvent && (t.pointerType === ht || t.pointerType === ft), e = e => { t(e) ? this.touchStartX = e.clientX : this._pointerEvent || (this.touchStartX = e.touches[0].clientX) }, n = t => { this.touchDeltaX = t.touches && t.touches.length > 1 ? 0 : t.touches[0].clientX - this.touchStartX }, i = e => { t(e) && (this.touchDeltaX = e.clientX - this.touchStartX), this._handleSwipe(), "hover" === this._config.pause && (this.pause(), this.touchTimeout && clearTimeout(this.touchTimeout), this.touchTimeout = setTimeout((t => this.cycle(t)), T + this._config.interval)) }; a.default.find(rt, this._element).forEach((t => { o.default.on(t, V, (t => t.preventDefault())) })), this._pointerEvent ? (o.default.on(this._element, Q, (t => e(t))), o.default.on(this._element, F, (t => i(t))), this._element.classList.add(nt)) : (o.default.on(this._element, H, (t => e(t))), o.default.on(this._element, B, (t => n(t))), o.default.on(this._element, z, (t => i(t)))) } _keydown(t) { if (/input|textarea/i.test(t.target.tagName)) return; const e = I[t.key]; e && (t.preventDefault(), this._slide(e)) } _getItemIndex(t) { return this._items = t && t.parentNode ? a.default.find(ot, t.parentNode) : [], this._items.indexOf(t) } _getItemByOrder(t, e) { const n = t === $; return A(this._items, e, n, this._config.wrap) } _triggerSlideEvent(t, e) { const n = this._getItemIndex(t), i = this._getItemIndex(a.default.findOne(st, this._element)); return o.default.trigger(this._element, M, { relatedTarget: t, direction: e, from: i, to: n }) } _setActiveIndicatorElement(t) { if (this._indicatorsElement) { const e = a.default.findOne(it, this._indicatorsElement); e.classList.remove(Y), e.removeAttribute("aria-current"); const n = a.default.find(ct, this._indicatorsElement); for (let e = 0; e < n.length; e++)if (Number.parseInt(n[e].getAttribute("data-bs-slide-to"), 10) === this._getItemIndex(t)) { n[e].classList.add(Y), n[e].setAttribute("aria-current", "true"); break } } } _updateInterval() { const t = this._activeElement || a.default.findOne(st, this._element); if (!t) return; const e = Number.parseInt(t.getAttribute("data-bs-interval"), 10); e ? (this._config.defaultInterval = this._config.defaultInterval || this._config.interval, this._config.interval = e) : this._config.interval = this._config.defaultInterval || this._config.interval } _slide(t, e) { const n = this._directionToOrder(t), i = a.default.findOne(st, this._element), s = this._getItemIndex(i), r = e || this._getItemByOrder(n, i), l = this._getItemIndex(r), c = Boolean(this._interval), d = n === $, u = d ? J : Z, f = d ? tt : et, h = this._orderToDirection(n); if (r && r.classList.contains(Y)) return void (this._isSliding = !1); if (this._isSliding) return; if (this._triggerSlideEvent(r, h).defaultPrevented) return; if (!i || !r) return; this._isSliding = !0, c && this.pause(), this._setActiveIndicatorElement(r), this._activeElement = r; const p = () => { o.default.trigger(this._element, P, { relatedTarget: r, direction: h, from: s, to: l }) }; if (this._element.classList.contains(G)) { r.classList.add(f), _(r), i.classList.add(u), r.classList.add(u); const t = () => { r.classList.remove(u, f), r.classList.add(Y), i.classList.remove(Y, f, u), this._isSliding = !1, setTimeout(p, 0) }; this._queueCallback(t, i, !0) } else i.classList.remove(Y), r.classList.add(Y), this._isSliding = !1, p(); c && this.cycle() } _directionToOrder(t) { return [S, D].includes(t) ? w() ? t === D ? N : $ : t === D ? $ : N : t } _orderToDirection(t) { return [$, N].includes(t) ? w() ? t === N ? D : S : t === N ? S : D : t } static carouselInterface(t, e) { const n = pt.getOrCreateInstance(t, e); let { _config: i } = n; "object" == typeof e && (i = { ...i, ...e }); const s = "string" == typeof e ? e : i.slide; if ("number" == typeof e) n.to(e); else if ("string" == typeof s) { if (void 0 === n[s]) throw new TypeError(`No method named "${s}"`); n[s]() } else i.interval && i.ride && (n.pause(), n.cycle()) } static jQueryInterface(t) { return this.each((function () { pt.carouselInterface(this, t) })) } static dataApiClickHandler(t) { const e = f(this); if (!e || !e.classList.contains(X)) return; const n = { ...r.default.getDataAttributes(e), ...r.default.getDataAttributes(this) }, i = this.getAttribute("data-bs-slide-to"); i && (n.interval = !1), pt.carouselInterface(e, n), i && pt.getInstance(e).to(i), t.preventDefault() } } return o.default.on(document, K, dt, pt.dataApiClickHandler), o.default.on(window, U, (() => { const t = a.default.find(ut); for (let e = 0, n = t.length; e < n; e++)pt.carouselInterface(t[e], pt.getInstance(t[e])) })), E(pt), pt }(a.exports, p.exports, m.exports, l.exports) }(h); var g = h.exports, _ = { exports: {} };
	/*!
		  * Bootstrap collapse.js v5.1.3 (https://getbootstrap.com/)
		  * Copyright 2011-2021 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
		  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
		  */
	!function (t, e) { t.exports = function (t, e, n, i, s) { const o = t => t && "object" == typeof t && "default" in t ? t : { default: t }, r = o(t), a = o(e), l = o(n), c = o(i), d = o(s), u = t => null == t ? `${t}` : {}.toString.call(t).match(/\s([a-z]+)/i)[1].toLowerCase(), f = t => { let e = t.getAttribute("data-bs-target"); if (!e || "#" === e) { let n = t.getAttribute("href"); if (!n || !n.includes("#") && !n.startsWith(".")) return null; n.includes("#") && !n.startsWith("#") && (n = `#${n.split("#")[1]}`), e = n && "#" !== n ? n.trim() : null } return e }, h = t => { const e = f(t); return e && document.querySelector(e) ? e : null }, p = t => { const e = f(t); return e ? document.querySelector(e) : null }, m = t => !(!t || "object" != typeof t) && (void 0 !== t.jquery && (t = t[0]), void 0 !== t.nodeType), g = t => m(t) ? t.jquery ? t[0] : t : "string" == typeof t && t.length > 0 ? document.querySelector(t) : null, _ = (t, e, n) => { Object.keys(n).forEach((i => { const s = n[i], o = e[i], r = o && m(o) ? "element" : u(o); if (!new RegExp(s).test(r)) throw new TypeError(`${t.toUpperCase()}: Option "${i}" provided type "${r}" but expected type "${s}".`) })) }, b = t => { t.offsetHeight }, v = () => { const { jQuery: t } = window; return t && !document.body.hasAttribute("data-bs-no-jquery") ? t : null }, y = [], w = t => { "loading" === document.readyState ? (y.length || document.addEventListener("DOMContentLoaded", (() => { y.forEach((t => t())) })), y.push(t)) : t() }, E = t => { w((() => { const e = v(); if (e) { const n = t.NAME, i = e.fn[n]; e.fn[n] = t.jQueryInterface, e.fn[n].Constructor = t, e.fn[n].noConflict = () => (e.fn[n] = i, t.jQueryInterface) } })) }, A = "collapse", x = "bs.collapse", C = `.${x}`, O = { toggle: !0, parent: null }, T = { toggle: "boolean", parent: "(null|element)" }, k = `show${C}`, L = `shown${C}`, j = `hide${C}`, $ = `hidden${C}`, N = `click${C}.data-api`, D = "show", S = "collapse", I = "collapsing", M = "collapsed", P = `:scope .${S} .${S}`, q = "collapse-horizontal", R = "width", W = "height", H = ".collapse.show, .collapse.collapsing", B = '[data-bs-toggle="collapse"]'; class z extends d.default { constructor(t, e) { super(t), this._isTransitioning = !1, this._config = this._getConfig(e), this._triggerArray = []; const n = c.default.find(B); for (let t = 0, e = n.length; t < e; t++) { const e = n[t], i = h(e), s = c.default.find(i).filter((t => t === this._element)); null !== i && s.length && (this._selector = i, this._triggerArray.push(e)) } this._initializeChildren(), this._config.parent || this._addAriaAndCollapsedClass(this._triggerArray, this._isShown()), this._config.toggle && this.toggle() } static get Default() { return O } static get NAME() { return A } toggle() { this._isShown() ? this.hide() : this.show() } show() { if (this._isTransitioning || this._isShown()) return; let t, e = []; if (this._config.parent) { const t = c.default.find(P, this._config.parent); e = c.default.find(H, this._config.parent).filter((e => !t.includes(e))) } const n = c.default.findOne(this._selector); if (e.length) { const i = e.find((t => n !== t)); if (t = i ? z.getInstance(i) : null, t && t._isTransitioning) return } if (a.default.trigger(this._element, k).defaultPrevented) return; e.forEach((e => { n !== e && z.getOrCreateInstance(e, { toggle: !1 }).hide(), t || r.default.set(e, x, null) })); const i = this._getDimension(); this._element.classList.remove(S), this._element.classList.add(I), this._element.style[i] = 0, this._addAriaAndCollapsedClass(this._triggerArray, !0), this._isTransitioning = !0; const s = () => { this._isTransitioning = !1, this._element.classList.remove(I), this._element.classList.add(S, D), this._element.style[i] = "", a.default.trigger(this._element, L) }, o = `scroll${i[0].toUpperCase() + i.slice(1)}`; this._queueCallback(s, this._element, !0), this._element.style[i] = `${this._element[o]}px` } hide() { if (this._isTransitioning || !this._isShown()) return; if (a.default.trigger(this._element, j).defaultPrevented) return; const t = this._getDimension(); this._element.style[t] = `${this._element.getBoundingClientRect()[t]}px`, b(this._element), this._element.classList.add(I), this._element.classList.remove(S, D); const e = this._triggerArray.length; for (let t = 0; t < e; t++) { const e = this._triggerArray[t], n = p(e); n && !this._isShown(n) && this._addAriaAndCollapsedClass([e], !1) } this._isTransitioning = !0; const n = () => { this._isTransitioning = !1, this._element.classList.remove(I), this._element.classList.add(S), a.default.trigger(this._element, $) }; this._element.style[t] = "", this._queueCallback(n, this._element, !0) } _isShown(t = this._element) { return t.classList.contains(D) } _getConfig(t) { return (t = { ...O, ...l.default.getDataAttributes(this._element), ...t }).toggle = Boolean(t.toggle), t.parent = g(t.parent), _(A, t, T), t } _getDimension() { return this._element.classList.contains(q) ? R : W } _initializeChildren() { if (!this._config.parent) return; const t = c.default.find(P, this._config.parent); c.default.find(B, this._config.parent).filter((e => !t.includes(e))).forEach((t => { const e = p(t); e && this._addAriaAndCollapsedClass([t], this._isShown(e)) })) } _addAriaAndCollapsedClass(t, e) { t.length && t.forEach((t => { e ? t.classList.remove(M) : t.classList.add(M), t.setAttribute("aria-expanded", e) })) } static jQueryInterface(t) { return this.each((function () { const e = {}; "string" == typeof t && /show|hide/.test(t) && (e.toggle = !1); const n = z.getOrCreateInstance(this, e); if ("string" == typeof t) { if (void 0 === n[t]) throw new TypeError(`No method named "${t}"`); n[t]() } })) } } return a.default.on(document, N, B, (function (t) { ("A" === t.target.tagName || t.delegateTarget && "A" === t.delegateTarget.tagName) && t.preventDefault(); const e = h(this); c.default.find(e).forEach((t => { z.getOrCreateInstance(t, { toggle: !1 }).toggle() })) })), E(z), z }(c.exports, a.exports, p.exports, m.exports, l.exports) }(_); var b = _.exports, v = { exports: {} }, y = "top", w = "bottom", E = "right", A = "left", x = "auto", C = [y, w, E, A], O = "start", T = "end", k = "clippingParents", L = "viewport", j = "popper", $ = "reference", N = C.reduce((function (t, e) { return t.concat([e + "-" + O, e + "-" + T]) }), []), D = [].concat(C, [x]).reduce((function (t, e) { return t.concat([e, e + "-" + O, e + "-" + T]) }), []), S = "beforeRead", I = "read", M = "afterRead", P = "beforeMain", q = "main", R = "afterMain", W = "beforeWrite", H = "write", B = "afterWrite", z = [S, I, M, P, q, R, W, H, B]; function Q(t) { return t ? (t.nodeName || "").toLowerCase() : null } function F(t) { if (null == t) return window; if ("[object Window]" !== t.toString()) { var e = t.ownerDocument; return e && e.defaultView || window } return t } function V(t) { return t instanceof F(t).Element || t instanceof Element } function U(t) { return t instanceof F(t).HTMLElement || t instanceof HTMLElement } function K(t) { return "undefined" != typeof ShadowRoot && (t instanceof F(t).ShadowRoot || t instanceof ShadowRoot) } var X = { name: "applyStyles", enabled: !0, phase: "write", fn: function (t) { var e = t.state; Object.keys(e.elements).forEach((function (t) { var n = e.styles[t] || {}, i = e.attributes[t] || {}, s = e.elements[t]; U(s) && Q(s) && (Object.assign(s.style, n), Object.keys(i).forEach((function (t) { var e = i[t]; !1 === e ? s.removeAttribute(t) : s.setAttribute(t, !0 === e ? "" : e) }))) })) }, effect: function (t) { var e = t.state, n = { popper: { position: e.options.strategy, left: "0", top: "0", margin: "0" }, arrow: { position: "absolute" }, reference: {} }; return Object.assign(e.elements.popper.style, n.popper), e.styles = n, e.elements.arrow && Object.assign(e.elements.arrow.style, n.arrow), function () { Object.keys(e.elements).forEach((function (t) { var i = e.elements[t], s = e.attributes[t] || {}, o = Object.keys(e.styles.hasOwnProperty(t) ? e.styles[t] : n[t]).reduce((function (t, e) { return t[e] = "", t }), {}); U(i) && Q(i) && (Object.assign(i.style, o), Object.keys(s).forEach((function (t) { i.removeAttribute(t) }))) })) } }, requires: ["computeStyles"] }; function Y(t) { return t.split("-")[0] } var G = Math.max, Z = Math.min, J = Math.round; function tt(t, e) { void 0 === e && (e = !1); var n = t.getBoundingClientRect(), i = 1, s = 1; if (U(t) && e) { var o = t.offsetHeight, r = t.offsetWidth; r > 0 && (i = J(n.width) / r || 1), o > 0 && (s = J(n.height) / o || 1) } return { width: n.width / i, height: n.height / s, top: n.top / s, right: n.right / i, bottom: n.bottom / s, left: n.left / i, x: n.left / i, y: n.top / s } } function et(t) { var e = tt(t), n = t.offsetWidth, i = t.offsetHeight; return Math.abs(e.width - n) <= 1 && (n = e.width), Math.abs(e.height - i) <= 1 && (i = e.height), { x: t.offsetLeft, y: t.offsetTop, width: n, height: i } } function nt(t, e) { var n = e.getRootNode && e.getRootNode(); if (t.contains(e)) return !0; if (n && K(n)) { var i = e; do { if (i && t.isSameNode(i)) return !0; i = i.parentNode || i.host } while (i) } return !1 } function it(t) { return F(t).getComputedStyle(t) } function st(t) { return ["table", "td", "th"].indexOf(Q(t)) >= 0 } function ot(t) { return ((V(t) ? t.ownerDocument : t.document) || window.document).documentElement } function rt(t) { return "html" === Q(t) ? t : t.assignedSlot || t.parentNode || (K(t) ? t.host : null) || ot(t) } function at(t) { return U(t) && "fixed" !== it(t).position ? t.offsetParent : null } function lt(t) { for (var e = F(t), n = at(t); n && st(n) && "static" === it(n).position;)n = at(n); return n && ("html" === Q(n) || "body" === Q(n) && "static" === it(n).position) ? e : n || function (t) { var e = -1 !== navigator.userAgent.toLowerCase().indexOf("firefox"); if (-1 !== navigator.userAgent.indexOf("Trident") && U(t) && "fixed" === it(t).position) return null; for (var n = rt(t); U(n) && ["html", "body"].indexOf(Q(n)) < 0;) { var i = it(n); if ("none" !== i.transform || "none" !== i.perspective || "paint" === i.contain || -1 !== ["transform", "perspective"].indexOf(i.willChange) || e && "filter" === i.willChange || e && i.filter && "none" !== i.filter) return n; n = n.parentNode } return null }(t) || e } function ct(t) { return ["top", "bottom"].indexOf(t) >= 0 ? "x" : "y" } function dt(t, e, n) { return G(t, Z(e, n)) } function ut(t) { return Object.assign({}, { top: 0, right: 0, bottom: 0, left: 0 }, t) } function ft(t, e) { return e.reduce((function (e, n) { return e[n] = t, e }), {}) } var ht = { name: "arrow", enabled: !0, phase: "main", fn: function (t) { var e, n = t.state, i = t.name, s = t.options, o = n.elements.arrow, r = n.modifiersData.popperOffsets, a = Y(n.placement), l = ct(a), c = [A, E].indexOf(a) >= 0 ? "height" : "width"; if (o && r) { var d = function (t, e) { return ut("number" != typeof (t = "function" == typeof t ? t(Object.assign({}, e.rects, { placement: e.placement })) : t) ? t : ft(t, C)) }(s.padding, n), u = et(o), f = "y" === l ? y : A, h = "y" === l ? w : E, p = n.rects.reference[c] + n.rects.reference[l] - r[l] - n.rects.popper[c], m = r[l] - n.rects.reference[l], g = lt(o), _ = g ? "y" === l ? g.clientHeight || 0 : g.clientWidth || 0 : 0, b = p / 2 - m / 2, v = d[f], x = _ - u[c] - d[h], O = _ / 2 - u[c] / 2 + b, T = dt(v, O, x), k = l; n.modifiersData[i] = ((e = {})[k] = T, e.centerOffset = T - O, e) } }, effect: function (t) { var e = t.state, n = t.options.element, i = void 0 === n ? "[data-popper-arrow]" : n; null != i && ("string" != typeof i || (i = e.elements.popper.querySelector(i))) && nt(e.elements.popper, i) && (e.elements.arrow = i) }, requires: ["popperOffsets"], requiresIfExists: ["preventOverflow"] }; function pt(t) { return t.split("-")[1] } var mt = { top: "auto", right: "auto", bottom: "auto", left: "auto" }; function gt(t) { var e, n = t.popper, i = t.popperRect, s = t.placement, o = t.variation, r = t.offsets, a = t.position, l = t.gpuAcceleration, c = t.adaptive, d = t.roundOffsets, u = t.isFixed, f = !0 === d ? function (t) { var e = t.x, n = t.y, i = window.devicePixelRatio || 1; return { x: J(e * i) / i || 0, y: J(n * i) / i || 0 } }(r) : "function" == typeof d ? d(r) : r, h = f.x, p = void 0 === h ? 0 : h, m = f.y, g = void 0 === m ? 0 : m, _ = r.hasOwnProperty("x"), b = r.hasOwnProperty("y"), v = A, x = y, C = window; if (c) { var O = lt(n), k = "clientHeight", L = "clientWidth"; if (O === F(n) && "static" !== it(O = ot(n)).position && "absolute" === a && (k = "scrollHeight", L = "scrollWidth"), O = O, s === y || (s === A || s === E) && o === T) x = w, g -= (u && C.visualViewport ? C.visualViewport.height : O[k]) - i.height, g *= l ? 1 : -1; if (s === A || (s === y || s === w) && o === T) v = E, p -= (u && C.visualViewport ? C.visualViewport.width : O[L]) - i.width, p *= l ? 1 : -1 } var j, $ = Object.assign({ position: a }, c && mt); return l ? Object.assign({}, $, ((j = {})[x] = b ? "0" : "", j[v] = _ ? "0" : "", j.transform = (C.devicePixelRatio || 1) <= 1 ? "translate(" + p + "px, " + g + "px)" : "translate3d(" + p + "px, " + g + "px, 0)", j)) : Object.assign({}, $, ((e = {})[x] = b ? g + "px" : "", e[v] = _ ? p + "px" : "", e.transform = "", e)) } var _t = { name: "computeStyles", enabled: !0, phase: "beforeWrite", fn: function (t) { var e = t.state, n = t.options, i = n.gpuAcceleration, s = void 0 === i || i, o = n.adaptive, r = void 0 === o || o, a = n.roundOffsets, l = void 0 === a || a, c = { placement: Y(e.placement), variation: pt(e.placement), popper: e.elements.popper, popperRect: e.rects.popper, gpuAcceleration: s, isFixed: "fixed" === e.options.strategy }; null != e.modifiersData.popperOffsets && (e.styles.popper = Object.assign({}, e.styles.popper, gt(Object.assign({}, c, { offsets: e.modifiersData.popperOffsets, position: e.options.strategy, adaptive: r, roundOffsets: l })))), null != e.modifiersData.arrow && (e.styles.arrow = Object.assign({}, e.styles.arrow, gt(Object.assign({}, c, { offsets: e.modifiersData.arrow, position: "absolute", adaptive: !1, roundOffsets: l })))), e.attributes.popper = Object.assign({}, e.attributes.popper, { "data-popper-placement": e.placement }) }, data: {} }, bt = { passive: !0 }; var vt = { name: "eventListeners", enabled: !0, phase: "write", fn: function () { }, effect: function (t) { var e = t.state, n = t.instance, i = t.options, s = i.scroll, o = void 0 === s || s, r = i.resize, a = void 0 === r || r, l = F(e.elements.popper), c = [].concat(e.scrollParents.reference, e.scrollParents.popper); return o && c.forEach((function (t) { t.addEventListener("scroll", n.update, bt) })), a && l.addEventListener("resize", n.update, bt), function () { o && c.forEach((function (t) { t.removeEventListener("scroll", n.update, bt) })), a && l.removeEventListener("resize", n.update, bt) } }, data: {} }, yt = { left: "right", right: "left", bottom: "top", top: "bottom" }; function wt(t) { return t.replace(/left|right|bottom|top/g, (function (t) { return yt[t] })) } var Et = { start: "end", end: "start" }; function At(t) { return t.replace(/start|end/g, (function (t) { return Et[t] })) } function xt(t) { var e = F(t); return { scrollLeft: e.pageXOffset, scrollTop: e.pageYOffset } } function Ct(t) { return tt(ot(t)).left + xt(t).scrollLeft } function Ot(t) { var e = it(t), n = e.overflow, i = e.overflowX, s = e.overflowY; return /auto|scroll|overlay|hidden/.test(n + s + i) } function Tt(t) { return ["html", "body", "#document"].indexOf(Q(t)) >= 0 ? t.ownerDocument.body : U(t) && Ot(t) ? t : Tt(rt(t)) } function kt(t, e) { var n; void 0 === e && (e = []); var i = Tt(t), s = i === (null == (n = t.ownerDocument) ? void 0 : n.body), o = F(i), r = s ? [o].concat(o.visualViewport || [], Ot(i) ? i : []) : i, a = e.concat(r); return s ? a : a.concat(kt(rt(r))) } function Lt(t) { return Object.assign({}, t, { left: t.x, top: t.y, right: t.x + t.width, bottom: t.y + t.height }) } function jt(t, e) { return e === L ? Lt(function (t) { var e = F(t), n = ot(t), i = e.visualViewport, s = n.clientWidth, o = n.clientHeight, r = 0, a = 0; return i && (s = i.width, o = i.height, /^((?!chrome|android).)*safari/i.test(navigator.userAgent) || (r = i.offsetLeft, a = i.offsetTop)), { width: s, height: o, x: r + Ct(t), y: a } }(t)) : V(e) ? function (t) { var e = tt(t); return e.top = e.top + t.clientTop, e.left = e.left + t.clientLeft, e.bottom = e.top + t.clientHeight, e.right = e.left + t.clientWidth, e.width = t.clientWidth, e.height = t.clientHeight, e.x = e.left, e.y = e.top, e }(e) : Lt(function (t) { var e, n = ot(t), i = xt(t), s = null == (e = t.ownerDocument) ? void 0 : e.body, o = G(n.scrollWidth, n.clientWidth, s ? s.scrollWidth : 0, s ? s.clientWidth : 0), r = G(n.scrollHeight, n.clientHeight, s ? s.scrollHeight : 0, s ? s.clientHeight : 0), a = -i.scrollLeft + Ct(t), l = -i.scrollTop; return "rtl" === it(s || n).direction && (a += G(n.clientWidth, s ? s.clientWidth : 0) - o), { width: o, height: r, x: a, y: l } }(ot(t))) } function $t(t, e, n) { var i = "clippingParents" === e ? function (t) { var e = kt(rt(t)), n = ["absolute", "fixed"].indexOf(it(t).position) >= 0, i = n && U(t) ? lt(t) : t; return V(i) ? e.filter((function (t) { return V(t) && nt(t, i) && "body" !== Q(t) && (!n || "static" !== it(t).position) })) : [] }(t) : [].concat(e), s = [].concat(i, [n]), o = s[0], r = s.reduce((function (e, n) { var i = jt(t, n); return e.top = G(i.top, e.top), e.right = Z(i.right, e.right), e.bottom = Z(i.bottom, e.bottom), e.left = G(i.left, e.left), e }), jt(t, o)); return r.width = r.right - r.left, r.height = r.bottom - r.top, r.x = r.left, r.y = r.top, r } function Nt(t) { var e, n = t.reference, i = t.element, s = t.placement, o = s ? Y(s) : null, r = s ? pt(s) : null, a = n.x + n.width / 2 - i.width / 2, l = n.y + n.height / 2 - i.height / 2; switch (o) { case y: e = { x: a, y: n.y - i.height }; break; case w: e = { x: a, y: n.y + n.height }; break; case E: e = { x: n.x + n.width, y: l }; break; case A: e = { x: n.x - i.width, y: l }; break; default: e = { x: n.x, y: n.y } }var c = o ? ct(o) : null; if (null != c) { var d = "y" === c ? "height" : "width"; switch (r) { case O: e[c] = e[c] - (n[d] / 2 - i[d] / 2); break; case T: e[c] = e[c] + (n[d] / 2 - i[d] / 2) } } return e } function Dt(t, e) { void 0 === e && (e = {}); var n = e, i = n.placement, s = void 0 === i ? t.placement : i, o = n.boundary, r = void 0 === o ? k : o, a = n.rootBoundary, l = void 0 === a ? L : a, c = n.elementContext, d = void 0 === c ? j : c, u = n.altBoundary, f = void 0 !== u && u, h = n.padding, p = void 0 === h ? 0 : h, m = ut("number" != typeof p ? p : ft(p, C)), g = d === j ? $ : j, _ = t.rects.popper, b = t.elements[f ? g : d], v = $t(V(b) ? b : b.contextElement || ot(t.elements.popper), r, l), A = tt(t.elements.reference), x = Nt({ reference: A, element: _, strategy: "absolute", placement: s }), O = Lt(Object.assign({}, _, x)), T = d === j ? O : A, N = { top: v.top - T.top + m.top, bottom: T.bottom - v.bottom + m.bottom, left: v.left - T.left + m.left, right: T.right - v.right + m.right }, D = t.modifiersData.offset; if (d === j && D) { var S = D[s]; Object.keys(N).forEach((function (t) { var e = [E, w].indexOf(t) >= 0 ? 1 : -1, n = [y, w].indexOf(t) >= 0 ? "y" : "x"; N[t] += S[n] * e })) } return N } function St(t, e) { void 0 === e && (e = {}); var n = e, i = n.placement, s = n.boundary, o = n.rootBoundary, r = n.padding, a = n.flipVariations, l = n.allowedAutoPlacements, c = void 0 === l ? D : l, d = pt(i), u = d ? a ? N : N.filter((function (t) { return pt(t) === d })) : C, f = u.filter((function (t) { return c.indexOf(t) >= 0 })); 0 === f.length && (f = u); var h = f.reduce((function (e, n) { return e[n] = Dt(t, { placement: n, boundary: s, rootBoundary: o, padding: r })[Y(n)], e }), {}); return Object.keys(h).sort((function (t, e) { return h[t] - h[e] })) } var It = { name: "flip", enabled: !0, phase: "main", fn: function (t) { var e = t.state, n = t.options, i = t.name; if (!e.modifiersData[i]._skip) { for (var s = n.mainAxis, o = void 0 === s || s, r = n.altAxis, a = void 0 === r || r, l = n.fallbackPlacements, c = n.padding, d = n.boundary, u = n.rootBoundary, f = n.altBoundary, h = n.flipVariations, p = void 0 === h || h, m = n.allowedAutoPlacements, g = e.options.placement, _ = Y(g), b = l || (_ === g || !p ? [wt(g)] : function (t) { if (Y(t) === x) return []; var e = wt(t); return [At(t), e, At(e)] }(g)), v = [g].concat(b).reduce((function (t, n) { return t.concat(Y(n) === x ? St(e, { placement: n, boundary: d, rootBoundary: u, padding: c, flipVariations: p, allowedAutoPlacements: m }) : n) }), []), C = e.rects.reference, T = e.rects.popper, k = new Map, L = !0, j = v[0], $ = 0; $ < v.length; $++) { var N = v[$], D = Y(N), S = pt(N) === O, I = [y, w].indexOf(D) >= 0, M = I ? "width" : "height", P = Dt(e, { placement: N, boundary: d, rootBoundary: u, altBoundary: f, padding: c }), q = I ? S ? E : A : S ? w : y; C[M] > T[M] && (q = wt(q)); var R = wt(q), W = []; if (o && W.push(P[D] <= 0), a && W.push(P[q] <= 0, P[R] <= 0), W.every((function (t) { return t }))) { j = N, L = !1; break } k.set(N, W) } if (L) for (var H = function (t) { var e = v.find((function (e) { var n = k.get(e); if (n) return n.slice(0, t).every((function (t) { return t })) })); if (e) return j = e, "break" }, B = p ? 3 : 1; B > 0; B--) { if ("break" === H(B)) break } e.placement !== j && (e.modifiersData[i]._skip = !0, e.placement = j, e.reset = !0) } }, requiresIfExists: ["offset"], data: { _skip: !1 } }; function Mt(t, e, n) { return void 0 === n && (n = { x: 0, y: 0 }), { top: t.top - e.height - n.y, right: t.right - e.width + n.x, bottom: t.bottom - e.height + n.y, left: t.left - e.width - n.x } } function Pt(t) { return [y, E, w, A].some((function (e) { return t[e] >= 0 })) } var qt = { name: "hide", enabled: !0, phase: "main", requiresIfExists: ["preventOverflow"], fn: function (t) { var e = t.state, n = t.name, i = e.rects.reference, s = e.rects.popper, o = e.modifiersData.preventOverflow, r = Dt(e, { elementContext: "reference" }), a = Dt(e, { altBoundary: !0 }), l = Mt(r, i), c = Mt(a, s, o), d = Pt(l), u = Pt(c); e.modifiersData[n] = { referenceClippingOffsets: l, popperEscapeOffsets: c, isReferenceHidden: d, hasPopperEscaped: u }, e.attributes.popper = Object.assign({}, e.attributes.popper, { "data-popper-reference-hidden": d, "data-popper-escaped": u }) } }; var Rt = { name: "offset", enabled: !0, phase: "main", requires: ["popperOffsets"], fn: function (t) { var e = t.state, n = t.options, i = t.name, s = n.offset, o = void 0 === s ? [0, 0] : s, r = D.reduce((function (t, n) { return t[n] = function (t, e, n) { var i = Y(t), s = [A, y].indexOf(i) >= 0 ? -1 : 1, o = "function" == typeof n ? n(Object.assign({}, e, { placement: t })) : n, r = o[0], a = o[1]; return r = r || 0, a = (a || 0) * s, [A, E].indexOf(i) >= 0 ? { x: a, y: r } : { x: r, y: a } }(n, e.rects, o), t }), {}), a = r[e.placement], l = a.x, c = a.y; null != e.modifiersData.popperOffsets && (e.modifiersData.popperOffsets.x += l, e.modifiersData.popperOffsets.y += c), e.modifiersData[i] = r } }; var Wt = { name: "popperOffsets", enabled: !0, phase: "read", fn: function (t) { var e = t.state, n = t.name; e.modifiersData[n] = Nt({ reference: e.rects.reference, element: e.rects.popper, strategy: "absolute", placement: e.placement }) }, data: {} }; var Ht = { name: "preventOverflow", enabled: !0, phase: "main", fn: function (t) { var e = t.state, n = t.options, i = t.name, s = n.mainAxis, o = void 0 === s || s, r = n.altAxis, a = void 0 !== r && r, l = n.boundary, c = n.rootBoundary, d = n.altBoundary, u = n.padding, f = n.tether, h = void 0 === f || f, p = n.tetherOffset, m = void 0 === p ? 0 : p, g = Dt(e, { boundary: l, rootBoundary: c, padding: u, altBoundary: d }), _ = Y(e.placement), b = pt(e.placement), v = !b, x = ct(_), C = "x" === x ? "y" : "x", T = e.modifiersData.popperOffsets, k = e.rects.reference, L = e.rects.popper, j = "function" == typeof m ? m(Object.assign({}, e.rects, { placement: e.placement })) : m, $ = "number" == typeof j ? { mainAxis: j, altAxis: j } : Object.assign({ mainAxis: 0, altAxis: 0 }, j), N = e.modifiersData.offset ? e.modifiersData.offset[e.placement] : null, D = { x: 0, y: 0 }; if (T) { if (o) { var S, I = "y" === x ? y : A, M = "y" === x ? w : E, P = "y" === x ? "height" : "width", q = T[x], R = q + g[I], W = q - g[M], H = h ? -L[P] / 2 : 0, B = b === O ? k[P] : L[P], z = b === O ? -L[P] : -k[P], Q = e.elements.arrow, F = h && Q ? et(Q) : { width: 0, height: 0 }, V = e.modifiersData["arrow#persistent"] ? e.modifiersData["arrow#persistent"].padding : { top: 0, right: 0, bottom: 0, left: 0 }, U = V[I], K = V[M], X = dt(0, k[P], F[P]), J = v ? k[P] / 2 - H - X - U - $.mainAxis : B - X - U - $.mainAxis, tt = v ? -k[P] / 2 + H + X + K + $.mainAxis : z + X + K + $.mainAxis, nt = e.elements.arrow && lt(e.elements.arrow), it = nt ? "y" === x ? nt.clientTop || 0 : nt.clientLeft || 0 : 0, st = null != (S = null == N ? void 0 : N[x]) ? S : 0, ot = q + tt - st, rt = dt(h ? Z(R, q + J - st - it) : R, q, h ? G(W, ot) : W); T[x] = rt, D[x] = rt - q } if (a) { var at, ut = "x" === x ? y : A, ft = "x" === x ? w : E, ht = T[C], mt = "y" === C ? "height" : "width", gt = ht + g[ut], _t = ht - g[ft], bt = -1 !== [y, A].indexOf(_), vt = null != (at = null == N ? void 0 : N[C]) ? at : 0, yt = bt ? gt : ht - k[mt] - L[mt] - vt + $.altAxis, wt = bt ? ht + k[mt] + L[mt] - vt - $.altAxis : _t, Et = h && bt ? function (t, e, n) { var i = dt(t, e, n); return i > n ? n : i }(yt, ht, wt) : dt(h ? yt : gt, ht, h ? wt : _t); T[C] = Et, D[C] = Et - ht } e.modifiersData[i] = D } }, requiresIfExists: ["offset"] }; function Bt(t, e, n) { void 0 === n && (n = !1); var i, s, o = U(e), r = U(e) && function (t) { var e = t.getBoundingClientRect(), n = J(e.width) / t.offsetWidth || 1, i = J(e.height) / t.offsetHeight || 1; return 1 !== n || 1 !== i }(e), a = ot(e), l = tt(t, r), c = { scrollLeft: 0, scrollTop: 0 }, d = { x: 0, y: 0 }; return (o || !o && !n) && (("body" !== Q(e) || Ot(a)) && (c = (i = e) !== F(i) && U(i) ? { scrollLeft: (s = i).scrollLeft, scrollTop: s.scrollTop } : xt(i)), U(e) ? ((d = tt(e, !0)).x += e.clientLeft, d.y += e.clientTop) : a && (d.x = Ct(a))), { x: l.left + c.scrollLeft - d.x, y: l.top + c.scrollTop - d.y, width: l.width, height: l.height } } function zt(t) { var e = new Map, n = new Set, i = []; function s(t) { n.add(t.name), [].concat(t.requires || [], t.requiresIfExists || []).forEach((function (t) { if (!n.has(t)) { var i = e.get(t); i && s(i) } })), i.push(t) } return t.forEach((function (t) { e.set(t.name, t) })), t.forEach((function (t) { n.has(t.name) || s(t) })), i } var Qt = { placement: "bottom", modifiers: [], strategy: "absolute" }; function Ft() { for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++)e[n] = arguments[n]; return !e.some((function (t) { return !(t && "function" == typeof t.getBoundingClientRect) })) } function Vt(t) { void 0 === t && (t = {}); var e = t, n = e.defaultModifiers, i = void 0 === n ? [] : n, s = e.defaultOptions, o = void 0 === s ? Qt : s; return function (t, e, n) { void 0 === n && (n = o); var s, r, a = { placement: "bottom", orderedModifiers: [], options: Object.assign({}, Qt, o), modifiersData: {}, elements: { reference: t, popper: e }, attributes: {}, styles: {} }, l = [], c = !1, d = { state: a, setOptions: function (n) { var s = "function" == typeof n ? n(a.options) : n; u(), a.options = Object.assign({}, o, a.options, s), a.scrollParents = { reference: V(t) ? kt(t) : t.contextElement ? kt(t.contextElement) : [], popper: kt(e) }; var r, c, f = function (t) { var e = zt(t); return z.reduce((function (t, n) { return t.concat(e.filter((function (t) { return t.phase === n }))) }), []) }((r = [].concat(i, a.options.modifiers), c = r.reduce((function (t, e) { var n = t[e.name]; return t[e.name] = n ? Object.assign({}, n, e, { options: Object.assign({}, n.options, e.options), data: Object.assign({}, n.data, e.data) }) : e, t }), {}), Object.keys(c).map((function (t) { return c[t] })))); return a.orderedModifiers = f.filter((function (t) { return t.enabled })), a.orderedModifiers.forEach((function (t) { var e = t.name, n = t.options, i = void 0 === n ? {} : n, s = t.effect; if ("function" == typeof s) { var o = s({ state: a, name: e, instance: d, options: i }), r = function () { }; l.push(o || r) } })), d.update() }, forceUpdate: function () { if (!c) { var t = a.elements, e = t.reference, n = t.popper; if (Ft(e, n)) { a.rects = { reference: Bt(e, lt(n), "fixed" === a.options.strategy), popper: et(n) }, a.reset = !1, a.placement = a.options.placement, a.orderedModifiers.forEach((function (t) { return a.modifiersData[t.name] = Object.assign({}, t.data) })); for (var i = 0; i < a.orderedModifiers.length; i++)if (!0 !== a.reset) { var s = a.orderedModifiers[i], o = s.fn, r = s.options, l = void 0 === r ? {} : r, u = s.name; "function" == typeof o && (a = o({ state: a, options: l, name: u, instance: d }) || a) } else a.reset = !1, i = -1 } } }, update: (s = function () { return new Promise((function (t) { d.forceUpdate(), t(a) })) }, function () { return r || (r = new Promise((function (t) { Promise.resolve().then((function () { r = void 0, t(s()) })) }))), r }), destroy: function () { u(), c = !0 } }; if (!Ft(t, e)) return d; function u() { l.forEach((function (t) { return t() })), l = [] } return d.setOptions(n).then((function (t) { !c && n.onFirstUpdate && n.onFirstUpdate(t) })), d } } var Ut = Vt(), Kt = Vt({ defaultModifiers: [vt, Wt, _t, X] }), Xt = Vt({ defaultModifiers: [vt, Wt, _t, X, Rt, It, Ht, ht, qt] }), Yt = o(Object.freeze({ __proto__: null, popperGenerator: Vt, detectOverflow: Dt, createPopperBase: Ut, createPopper: Xt, createPopperLite: Kt, top: y, bottom: w, right: E, left: A, auto: x, basePlacements: C, start: O, end: T, clippingParents: k, viewport: L, popper: j, reference: $, variationPlacements: N, placements: D, beforeRead: S, read: I, afterRead: M, beforeMain: P, main: q, afterMain: R, beforeWrite: W, write: H, afterWrite: B, modifierPhases: z, applyStyles: X, arrow: ht, computeStyles: _t, eventListeners: vt, flip: It, hide: qt, offset: Rt, popperOffsets: Wt, preventOverflow: Ht }));
	/*!
		  * Bootstrap dropdown.js v5.1.3 (https://getbootstrap.com/)
		  * Copyright 2011-2021 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
		  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
		  */
	!function (t, e) { t.exports = function (t, e, n, i, s) { const o = t => t && "object" == typeof t && "default" in t ? t : { default: t }; function r(t) { if (t && t.__esModule) return t; const e = Object.create(null); if (t) for (const n in t) if ("default" !== n) { const i = Object.getOwnPropertyDescriptor(t, n); Object.defineProperty(e, n, i.get ? i : { enumerable: !0, get: () => t[n] }) } return e.default = t, Object.freeze(e) } const a = r(t), l = o(e), c = o(n), d = o(i), u = o(s), f = t => null == t ? `${t}` : {}.toString.call(t).match(/\s([a-z]+)/i)[1].toLowerCase(), h = t => { let e = t.getAttribute("data-bs-target"); if (!e || "#" === e) { let n = t.getAttribute("href"); if (!n || !n.includes("#") && !n.startsWith(".")) return null; n.includes("#") && !n.startsWith("#") && (n = `#${n.split("#")[1]}`), e = n && "#" !== n ? n.trim() : null } return e }, p = t => { const e = h(t); return e ? document.querySelector(e) : null }, m = t => !(!t || "object" != typeof t) && (void 0 !== t.jquery && (t = t[0]), void 0 !== t.nodeType), g = t => m(t) ? t.jquery ? t[0] : t : "string" == typeof t && t.length > 0 ? document.querySelector(t) : null, _ = (t, e, n) => { Object.keys(n).forEach((i => { const s = n[i], o = e[i], r = o && m(o) ? "element" : f(o); if (!new RegExp(s).test(r)) throw new TypeError(`${t.toUpperCase()}: Option "${i}" provided type "${r}" but expected type "${s}".`) })) }, b = t => !(!m(t) || 0 === t.getClientRects().length) && "visible" === getComputedStyle(t).getPropertyValue("visibility"), v = t => !t || t.nodeType !== Node.ELEMENT_NODE || !!t.classList.contains("disabled") || (void 0 !== t.disabled ? t.disabled : t.hasAttribute("disabled") && "false" !== t.getAttribute("disabled")), y = () => { }, w = () => { const { jQuery: t } = window; return t && !document.body.hasAttribute("data-bs-no-jquery") ? t : null }, E = [], A = t => { "loading" === document.readyState ? (E.length || document.addEventListener("DOMContentLoaded", (() => { E.forEach((t => t())) })), E.push(t)) : t() }, x = () => "rtl" === document.documentElement.dir, C = t => { A((() => { const e = w(); if (e) { const n = t.NAME, i = e.fn[n]; e.fn[n] = t.jQueryInterface, e.fn[n].Constructor = t, e.fn[n].noConflict = () => (e.fn[n] = i, t.jQueryInterface) } })) }, O = (t, e, n, i) => { let s = t.indexOf(e); if (-1 === s) return t[!n && i ? t.length - 1 : 0]; const o = t.length; return s += n ? 1 : -1, i && (s = (s + o) % o), t[Math.max(0, Math.min(s, o - 1))] }, T = "dropdown", k = ".bs.dropdown", L = ".data-api", j = "Escape", $ = "Space", N = "Tab", D = "ArrowUp", S = "ArrowDown", I = 2, M = new RegExp(`${D}|${S}|${j}`), P = `hide${k}`, q = `hidden${k}`, R = `show${k}`, W = `shown${k}`, H = `click${k}${L}`, B = `keydown${k}${L}`, z = `keyup${k}${L}`, Q = "show", F = "dropup", V = "dropend", U = "dropstart", K = "navbar", X = '[data-bs-toggle="dropdown"]', Y = ".dropdown-menu", G = ".navbar-nav", Z = ".dropdown-menu .dropdown-item:not(.disabled):not(:disabled)", J = x() ? "top-end" : "top-start", tt = x() ? "top-start" : "top-end", et = x() ? "bottom-end" : "bottom-start", nt = x() ? "bottom-start" : "bottom-end", it = x() ? "left-start" : "right-start", st = x() ? "right-start" : "left-start", ot = { offset: [0, 2], boundary: "clippingParents", reference: "toggle", display: "dynamic", popperConfig: null, autoClose: !0 }, rt = { offset: "(array|string|function)", boundary: "(string|element)", reference: "(string|element|object)", display: "string", popperConfig: "(null|object|function)", autoClose: "(boolean|string)" }; class at extends u.default { constructor(t, e) { super(t), this._popper = null, this._config = this._getConfig(e), this._menu = this._getMenuElement(), this._inNavbar = this._detectNavbar() } static get Default() { return ot } static get DefaultType() { return rt } static get NAME() { return T } toggle() { return this._isShown() ? this.hide() : this.show() } show() { if (v(this._element) || this._isShown(this._menu)) return; const t = { relatedTarget: this._element }; if (l.default.trigger(this._element, R, t).defaultPrevented) return; const e = at.getParentFromElement(this._element); this._inNavbar ? c.default.setDataAttribute(this._menu, "popper", "none") : this._createPopper(e), "ontouchstart" in document.documentElement && !e.closest(G) && [].concat(...document.body.children).forEach((t => l.default.on(t, "mouseover", y))), this._element.focus(), this._element.setAttribute("aria-expanded", !0), this._menu.classList.add(Q), this._element.classList.add(Q), l.default.trigger(this._element, W, t) } hide() { if (v(this._element) || !this._isShown(this._menu)) return; const t = { relatedTarget: this._element }; this._completeHide(t) } dispose() { this._popper && this._popper.destroy(), super.dispose() } update() { this._inNavbar = this._detectNavbar(), this._popper && this._popper.update() } _completeHide(t) { l.default.trigger(this._element, P, t).defaultPrevented || ("ontouchstart" in document.documentElement && [].concat(...document.body.children).forEach((t => l.default.off(t, "mouseover", y))), this._popper && this._popper.destroy(), this._menu.classList.remove(Q), this._element.classList.remove(Q), this._element.setAttribute("aria-expanded", "false"), c.default.removeDataAttribute(this._menu, "popper"), l.default.trigger(this._element, q, t)) } _getConfig(t) { if (t = { ...this.constructor.Default, ...c.default.getDataAttributes(this._element), ...t }, _(T, t, this.constructor.DefaultType), "object" == typeof t.reference && !m(t.reference) && "function" != typeof t.reference.getBoundingClientRect) throw new TypeError(`${T.toUpperCase()}: Option "reference" provided type "object" without a required "getBoundingClientRect" method.`); return t } _createPopper(t) { if (void 0 === a) throw new TypeError("Bootstrap's dropdowns require Popper (https://popper.js.org)"); let e = this._element; "parent" === this._config.reference ? e = t : m(this._config.reference) ? e = g(this._config.reference) : "object" == typeof this._config.reference && (e = this._config.reference); const n = this._getPopperConfig(), i = n.modifiers.find((t => "applyStyles" === t.name && !1 === t.enabled)); this._popper = a.createPopper(e, this._menu, n), i && c.default.setDataAttribute(this._menu, "popper", "static") } _isShown(t = this._element) { return t.classList.contains(Q) } _getMenuElement() { return d.default.next(this._element, Y)[0] } _getPlacement() { const t = this._element.parentNode; if (t.classList.contains(V)) return it; if (t.classList.contains(U)) return st; const e = "end" === getComputedStyle(this._menu).getPropertyValue("--bs-position").trim(); return t.classList.contains(F) ? e ? tt : J : e ? nt : et } _detectNavbar() { return null !== this._element.closest(`.${K}`) } _getOffset() { const { offset: t } = this._config; return "string" == typeof t ? t.split(",").map((t => Number.parseInt(t, 10))) : "function" == typeof t ? e => t(e, this._element) : t } _getPopperConfig() { const t = { placement: this._getPlacement(), modifiers: [{ name: "preventOverflow", options: { boundary: this._config.boundary } }, { name: "offset", options: { offset: this._getOffset() } }] }; return "static" === this._config.display && (t.modifiers = [{ name: "applyStyles", enabled: !1 }]), { ...t, ..."function" == typeof this._config.popperConfig ? this._config.popperConfig(t) : this._config.popperConfig } } _selectMenuItem({ key: t, target: e }) { const n = d.default.find(Z, this._menu).filter(b); n.length && O(n, e, t === S, !n.includes(e)).focus() } static jQueryInterface(t) { return this.each((function () { const e = at.getOrCreateInstance(this, t); if ("string" == typeof t) { if (void 0 === e[t]) throw new TypeError(`No method named "${t}"`); e[t]() } })) } static clearMenus(t) { if (t && (t.button === I || "keyup" === t.type && t.key !== N)) return; const e = d.default.find(X); for (let n = 0, i = e.length; n < i; n++) { const i = at.getInstance(e[n]); if (!i || !1 === i._config.autoClose) continue; if (!i._isShown()) continue; const s = { relatedTarget: i._element }; if (t) { const e = t.composedPath(), n = e.includes(i._menu); if (e.includes(i._element) || "inside" === i._config.autoClose && !n || "outside" === i._config.autoClose && n) continue; if (i._menu.contains(t.target) && ("keyup" === t.type && t.key === N || /input|select|option|textarea|form/i.test(t.target.tagName))) continue; "click" === t.type && (s.clickEvent = t) } i._completeHide(s) } } static getParentFromElement(t) { return p(t) || t.parentNode } static dataApiKeydownHandler(t) { if (/input|textarea/i.test(t.target.tagName) ? t.key === $ || t.key !== j && (t.key !== S && t.key !== D || t.target.closest(Y)) : !M.test(t.key)) return; const e = this.classList.contains(Q); if (!e && t.key === j) return; if (t.preventDefault(), t.stopPropagation(), v(this)) return; const n = this.matches(X) ? this : d.default.prev(this, X)[0], i = at.getOrCreateInstance(n); if (t.key !== j) return t.key === D || t.key === S ? (e || i.show(), void i._selectMenuItem(t)) : void (e && t.key !== $ || at.clearMenus()); i.hide() } } return l.default.on(document, B, X, at.dataApiKeydownHandler), l.default.on(document, B, Y, at.dataApiKeydownHandler), l.default.on(document, H, at.clearMenus), l.default.on(document, z, at.clearMenus), l.default.on(document, H, X, (function (t) { t.preventDefault(), at.getOrCreateInstance(this).toggle() })), C(at), at }(Yt, a.exports, p.exports, m.exports, l.exports) }(v); var Gt = s(v.exports), Zt = { exports: {} };
	/*!
		  * Bootstrap modal.js v5.1.3 (https://getbootstrap.com/)
		  * Copyright 2011-2021 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
		  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
		  */
	!function (t, e) { t.exports = function (t, e, n, i) { const s = t => t && "object" == typeof t && "default" in t ? t : { default: t }, o = s(t), r = s(e), a = s(n), l = s(i), c = 1e3, d = "transitionend", u = t => null == t ? `${t}` : {}.toString.call(t).match(/\s([a-z]+)/i)[1].toLowerCase(), f = t => { let e = t.getAttribute("data-bs-target"); if (!e || "#" === e) { let n = t.getAttribute("href"); if (!n || !n.includes("#") && !n.startsWith(".")) return null; n.includes("#") && !n.startsWith("#") && (n = `#${n.split("#")[1]}`), e = n && "#" !== n ? n.trim() : null } return e }, h = t => { const e = f(t); return e ? document.querySelector(e) : null }, p = t => { if (!t) return 0; let { transitionDuration: e, transitionDelay: n } = window.getComputedStyle(t); const i = Number.parseFloat(e), s = Number.parseFloat(n); return i || s ? (e = e.split(",")[0], n = n.split(",")[0], (Number.parseFloat(e) + Number.parseFloat(n)) * c) : 0 }, m = t => { t.dispatchEvent(new Event(d)) }, g = t => !(!t || "object" != typeof t) && (void 0 !== t.jquery && (t = t[0]), void 0 !== t.nodeType), _ = t => g(t) ? t.jquery ? t[0] : t : "string" == typeof t && t.length > 0 ? document.querySelector(t) : null, b = (t, e, n) => { Object.keys(n).forEach((i => { const s = n[i], o = e[i], r = o && g(o) ? "element" : u(o); if (!new RegExp(s).test(r)) throw new TypeError(`${t.toUpperCase()}: Option "${i}" provided type "${r}" but expected type "${s}".`) })) }, v = t => !(!g(t) || 0 === t.getClientRects().length) && "visible" === getComputedStyle(t).getPropertyValue("visibility"), y = t => !t || t.nodeType !== Node.ELEMENT_NODE || !!t.classList.contains("disabled") || (void 0 !== t.disabled ? t.disabled : t.hasAttribute("disabled") && "false" !== t.getAttribute("disabled")), w = t => { t.offsetHeight }, E = () => { const { jQuery: t } = window; return t && !document.body.hasAttribute("data-bs-no-jquery") ? t : null }, A = [], x = t => { "loading" === document.readyState ? (A.length || document.addEventListener("DOMContentLoaded", (() => { A.forEach((t => t())) })), A.push(t)) : t() }, C = () => "rtl" === document.documentElement.dir, O = t => { x((() => { const e = E(); if (e) { const n = t.NAME, i = e.fn[n]; e.fn[n] = t.jQueryInterface, e.fn[n].Constructor = t, e.fn[n].noConflict = () => (e.fn[n] = i, t.jQueryInterface) } })) }, T = t => { "function" == typeof t && t() }, k = (t, e, n = !0) => { if (!n) return void T(t); const i = 5, s = p(e) + i; let o = !1; const r = ({ target: n }) => { n === e && (o = !0, e.removeEventListener(d, r), T(t)) }; e.addEventListener(d, r), setTimeout((() => { o || m(e) }), s) }, L = ".fixed-top, .fixed-bottom, .is-fixed, .sticky-top", j = ".sticky-top"; class $ { constructor() { this._element = document.body } getWidth() { const t = document.documentElement.clientWidth; return Math.abs(window.innerWidth - t) } hide() { const t = this.getWidth(); this._disableOverFlow(), this._setElementAttributes(this._element, "paddingRight", (e => e + t)), this._setElementAttributes(L, "paddingRight", (e => e + t)), this._setElementAttributes(j, "marginRight", (e => e - t)) } _disableOverFlow() { this._saveInitialAttribute(this._element, "overflow"), this._element.style.overflow = "hidden" } _setElementAttributes(t, e, n) { const i = this.getWidth(), s = t => { if (t !== this._element && window.innerWidth > t.clientWidth + i) return; this._saveInitialAttribute(t, e); const s = window.getComputedStyle(t)[e]; t.style[e] = `${n(Number.parseFloat(s))}px` }; this._applyManipulationCallback(t, s) } reset() { this._resetElementAttributes(this._element, "overflow"), this._resetElementAttributes(this._element, "paddingRight"), this._resetElementAttributes(L, "paddingRight"), this._resetElementAttributes(j, "marginRight") } _saveInitialAttribute(t, e) { const n = t.style[e]; n && r.default.setDataAttribute(t, e, n) } _resetElementAttributes(t, e) { const n = t => { const n = r.default.getDataAttribute(t, e); void 0 === n ? t.style.removeProperty(e) : (r.default.removeDataAttribute(t, e), t.style[e] = n) }; this._applyManipulationCallback(t, n) } _applyManipulationCallback(t, e) { g(t) ? e(t) : a.default.find(t, this._element).forEach(e) } isOverflowing() { return this.getWidth() > 0 } } const N = { className: "modal-backdrop", isVisible: !0, isAnimated: !1, rootElement: "body", clickCallback: null }, D = { className: "string", isVisible: "boolean", isAnimated: "boolean", rootElement: "(element|string)", clickCallback: "(function|null)" }, S = "backdrop", I = "fade", M = "show", P = `mousedown.bs.${S}`; class q { constructor(t) { this._config = this._getConfig(t), this._isAppended = !1, this._element = null } show(t) { this._config.isVisible ? (this._append(), this._config.isAnimated && w(this._getElement()), this._getElement().classList.add(M), this._emulateAnimation((() => { T(t) }))) : T(t) } hide(t) { this._config.isVisible ? (this._getElement().classList.remove(M), this._emulateAnimation((() => { this.dispose(), T(t) }))) : T(t) } _getElement() { if (!this._element) { const t = document.createElement("div"); t.className = this._config.className, this._config.isAnimated && t.classList.add(I), this._element = t } return this._element } _getConfig(t) { return (t = { ...N, ..."object" == typeof t ? t : {} }).rootElement = _(t.rootElement), b(S, t, D), t } _append() { this._isAppended || (this._config.rootElement.append(this._getElement()), o.default.on(this._getElement(), P, (() => { T(this._config.clickCallback) })), this._isAppended = !0) } dispose() { this._isAppended && (o.default.off(this._element, P), this._element.remove(), this._isAppended = !1) } _emulateAnimation(t) { k(t, this._getElement(), this._config.isAnimated) } } const R = { trapElement: null, autofocus: !0 }, W = { trapElement: "element", autofocus: "boolean" }, H = "focustrap", B = ".bs.focustrap", z = `focusin${B}`, Q = `keydown.tab${B}`, F = "Tab", V = "forward", U = "backward"; class K { constructor(t) { this._config = this._getConfig(t), this._isActive = !1, this._lastTabNavDirection = null } activate() { const { trapElement: t, autofocus: e } = this._config; this._isActive || (e && t.focus(), o.default.off(document, B), o.default.on(document, z, (t => this._handleFocusin(t))), o.default.on(document, Q, (t => this._handleKeydown(t))), this._isActive = !0) } deactivate() { this._isActive && (this._isActive = !1, o.default.off(document, B)) } _handleFocusin(t) { const { target: e } = t, { trapElement: n } = this._config; if (e === document || e === n || n.contains(e)) return; const i = a.default.focusableChildren(n); 0 === i.length ? n.focus() : this._lastTabNavDirection === U ? i[i.length - 1].focus() : i[0].focus() } _handleKeydown(t) { t.key === F && (this._lastTabNavDirection = t.shiftKey ? U : V) } _getConfig(t) { return t = { ...R, ..."object" == typeof t ? t : {} }, b(H, t, W), t } } const X = (t, e = "hide") => { const n = `click.dismiss${t.EVENT_KEY}`, i = t.NAME; o.default.on(document, n, `[data-bs-dismiss="${i}"]`, (function (n) { if (["A", "AREA"].includes(this.tagName) && n.preventDefault(), y(this)) return; const s = h(this) || this.closest(`.${i}`); t.getOrCreateInstance(s)[e]() })) }, Y = "modal", G = ".bs.modal", Z = "Escape", J = { backdrop: !0, keyboard: !0, focus: !0 }, tt = { backdrop: "(boolean|string)", keyboard: "boolean", focus: "boolean" }, et = `hide${G}`, nt = `hidePrevented${G}`, it = `hidden${G}`, st = `show${G}`, ot = `shown${G}`, rt = `resize${G}`, at = `click.dismiss${G}`, lt = `keydown.dismiss${G}`, ct = `mouseup.dismiss${G}`, dt = `mousedown.dismiss${G}`, ut = `click${G}.data-api`, ft = "modal-open", ht = "fade", pt = "show", mt = "modal-static", gt = ".modal.show", _t = ".modal-dialog", bt = ".modal-body", vt = '[data-bs-toggle="modal"]'; class yt extends l.default { constructor(t, e) { super(t), this._config = this._getConfig(e), this._dialog = a.default.findOne(_t, this._element), this._backdrop = this._initializeBackDrop(), this._focustrap = this._initializeFocusTrap(), this._isShown = !1, this._ignoreBackdropClick = !1, this._isTransitioning = !1, this._scrollBar = new $ } static get Default() { return J } static get NAME() { return Y } toggle(t) { return this._isShown ? this.hide() : this.show(t) } show(t) { this._isShown || this._isTransitioning || o.default.trigger(this._element, st, { relatedTarget: t }).defaultPrevented || (this._isShown = !0, this._isAnimated() && (this._isTransitioning = !0), this._scrollBar.hide(), document.body.classList.add(ft), this._adjustDialog(), this._setEscapeEvent(), this._setResizeEvent(), o.default.on(this._dialog, dt, (() => { o.default.one(this._element, ct, (t => { t.target === this._element && (this._ignoreBackdropClick = !0) })) })), this._showBackdrop((() => this._showElement(t)))) } hide() { if (!this._isShown || this._isTransitioning) return; if (o.default.trigger(this._element, et).defaultPrevented) return; this._isShown = !1; const t = this._isAnimated(); t && (this._isTransitioning = !0), this._setEscapeEvent(), this._setResizeEvent(), this._focustrap.deactivate(), this._element.classList.remove(pt), o.default.off(this._element, at), o.default.off(this._dialog, dt), this._queueCallback((() => this._hideModal()), this._element, t) } dispose() { [window, this._dialog].forEach((t => o.default.off(t, G))), this._backdrop.dispose(), this._focustrap.deactivate(), super.dispose() } handleUpdate() { this._adjustDialog() } _initializeBackDrop() { return new q({ isVisible: Boolean(this._config.backdrop), isAnimated: this._isAnimated() }) } _initializeFocusTrap() { return new K({ trapElement: this._element }) } _getConfig(t) { return t = { ...J, ...r.default.getDataAttributes(this._element), ..."object" == typeof t ? t : {} }, b(Y, t, tt), t } _showElement(t) { const e = this._isAnimated(), n = a.default.findOne(bt, this._dialog); this._element.parentNode && this._element.parentNode.nodeType === Node.ELEMENT_NODE || document.body.append(this._element), this._element.style.display = "block", this._element.removeAttribute("aria-hidden"), this._element.setAttribute("aria-modal", !0), this._element.setAttribute("role", "dialog"), this._element.scrollTop = 0, n && (n.scrollTop = 0), e && w(this._element), this._element.classList.add(pt); const i = () => { this._config.focus && this._focustrap.activate(), this._isTransitioning = !1, o.default.trigger(this._element, ot, { relatedTarget: t }) }; this._queueCallback(i, this._dialog, e) } _setEscapeEvent() { this._isShown ? o.default.on(this._element, lt, (t => { this._config.keyboard && t.key === Z ? (t.preventDefault(), this.hide()) : this._config.keyboard || t.key !== Z || this._triggerBackdropTransition() })) : o.default.off(this._element, lt) } _setResizeEvent() { this._isShown ? o.default.on(window, rt, (() => this._adjustDialog())) : o.default.off(window, rt) } _hideModal() { this._element.style.display = "none", this._element.setAttribute("aria-hidden", !0), this._element.removeAttribute("aria-modal"), this._element.removeAttribute("role"), this._isTransitioning = !1, this._backdrop.hide((() => { document.body.classList.remove(ft), this._resetAdjustments(), this._scrollBar.reset(), o.default.trigger(this._element, it) })) } _showBackdrop(t) { o.default.on(this._element, at, (t => { this._ignoreBackdropClick ? this._ignoreBackdropClick = !1 : t.target === t.currentTarget && (!0 === this._config.backdrop ? this.hide() : "static" === this._config.backdrop && this._triggerBackdropTransition()) })), this._backdrop.show(t) } _isAnimated() { return this._element.classList.contains(ht) } _triggerBackdropTransition() { if (o.default.trigger(this._element, nt).defaultPrevented) return; const { classList: t, scrollHeight: e, style: n } = this._element, i = e > document.documentElement.clientHeight; !i && "hidden" === n.overflowY || t.contains(mt) || (i || (n.overflowY = "hidden"), t.add(mt), this._queueCallback((() => { t.remove(mt), i || this._queueCallback((() => { n.overflowY = "" }), this._dialog) }), this._dialog), this._element.focus()) } _adjustDialog() { const t = this._element.scrollHeight > document.documentElement.clientHeight, e = this._scrollBar.getWidth(), n = e > 0; (!n && t && !C() || n && !t && C()) && (this._element.style.paddingLeft = `${e}px`), (n && !t && !C() || !n && t && C()) && (this._element.style.paddingRight = `${e}px`) } _resetAdjustments() { this._element.style.paddingLeft = "", this._element.style.paddingRight = "" } static jQueryInterface(t, e) { return this.each((function () { const n = yt.getOrCreateInstance(this, t); if ("string" == typeof t) { if (void 0 === n[t]) throw new TypeError(`No method named "${t}"`); n[t](e) } })) } } return o.default.on(document, ut, vt, (function (t) { const e = h(this);["A", "AREA"].includes(this.tagName) && t.preventDefault(), o.default.one(e, st, (t => { t.defaultPrevented || o.default.one(e, it, (() => { v(this) && this.focus() })) })); const n = a.default.findOne(gt); n && yt.getInstance(n).hide(), yt.getOrCreateInstance(e).toggle(this) })), X(yt), O(yt), yt }(a.exports, p.exports, m.exports, l.exports) }(Zt); var Jt = Zt.exports, te = { exports: {} };
	/*!
		  * Bootstrap offcanvas.js v5.1.3 (https://getbootstrap.com/)
		  * Copyright 2011-2021 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
		  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
		  */
	!function (t, e) { t.exports = function (t, e, n, i) { const s = t => t && "object" == typeof t && "default" in t ? t : { default: t }, o = s(t), r = s(e), a = s(n), l = s(i), c = 1e3, d = "transitionend", u = t => null == t ? `${t}` : {}.toString.call(t).match(/\s([a-z]+)/i)[1].toLowerCase(), f = t => { let e = t.getAttribute("data-bs-target"); if (!e || "#" === e) { let n = t.getAttribute("href"); if (!n || !n.includes("#") && !n.startsWith(".")) return null; n.includes("#") && !n.startsWith("#") && (n = `#${n.split("#")[1]}`), e = n && "#" !== n ? n.trim() : null } return e }, h = t => { const e = f(t); return e ? document.querySelector(e) : null }, p = t => { if (!t) return 0; let { transitionDuration: e, transitionDelay: n } = window.getComputedStyle(t); const i = Number.parseFloat(e), s = Number.parseFloat(n); return i || s ? (e = e.split(",")[0], n = n.split(",")[0], (Number.parseFloat(e) + Number.parseFloat(n)) * c) : 0 }, m = t => { t.dispatchEvent(new Event(d)) }, g = t => !(!t || "object" != typeof t) && (void 0 !== t.jquery && (t = t[0]), void 0 !== t.nodeType), _ = t => g(t) ? t.jquery ? t[0] : t : "string" == typeof t && t.length > 0 ? document.querySelector(t) : null, b = (t, e, n) => { Object.keys(n).forEach((i => { const s = n[i], o = e[i], r = o && g(o) ? "element" : u(o); if (!new RegExp(s).test(r)) throw new TypeError(`${t.toUpperCase()}: Option "${i}" provided type "${r}" but expected type "${s}".`) })) }, v = t => !(!g(t) || 0 === t.getClientRects().length) && "visible" === getComputedStyle(t).getPropertyValue("visibility"), y = t => !t || t.nodeType !== Node.ELEMENT_NODE || !!t.classList.contains("disabled") || (void 0 !== t.disabled ? t.disabled : t.hasAttribute("disabled") && "false" !== t.getAttribute("disabled")), w = t => { t.offsetHeight }, E = () => { const { jQuery: t } = window; return t && !document.body.hasAttribute("data-bs-no-jquery") ? t : null }, A = [], x = t => { "loading" === document.readyState ? (A.length || document.addEventListener("DOMContentLoaded", (() => { A.forEach((t => t())) })), A.push(t)) : t() }, C = t => { x((() => { const e = E(); if (e) { const n = t.NAME, i = e.fn[n]; e.fn[n] = t.jQueryInterface, e.fn[n].Constructor = t, e.fn[n].noConflict = () => (e.fn[n] = i, t.jQueryInterface) } })) }, O = t => { "function" == typeof t && t() }, T = (t, e, n = !0) => { if (!n) return void O(t); const i = 5, s = p(e) + i; let o = !1; const r = ({ target: n }) => { n === e && (o = !0, e.removeEventListener(d, r), O(t)) }; e.addEventListener(d, r), setTimeout((() => { o || m(e) }), s) }, k = ".fixed-top, .fixed-bottom, .is-fixed, .sticky-top", L = ".sticky-top"; class j { constructor() { this._element = document.body } getWidth() { const t = document.documentElement.clientWidth; return Math.abs(window.innerWidth - t) } hide() { const t = this.getWidth(); this._disableOverFlow(), this._setElementAttributes(this._element, "paddingRight", (e => e + t)), this._setElementAttributes(k, "paddingRight", (e => e + t)), this._setElementAttributes(L, "marginRight", (e => e - t)) } _disableOverFlow() { this._saveInitialAttribute(this._element, "overflow"), this._element.style.overflow = "hidden" } _setElementAttributes(t, e, n) { const i = this.getWidth(), s = t => { if (t !== this._element && window.innerWidth > t.clientWidth + i) return; this._saveInitialAttribute(t, e); const s = window.getComputedStyle(t)[e]; t.style[e] = `${n(Number.parseFloat(s))}px` }; this._applyManipulationCallback(t, s) } reset() { this._resetElementAttributes(this._element, "overflow"), this._resetElementAttributes(this._element, "paddingRight"), this._resetElementAttributes(k, "paddingRight"), this._resetElementAttributes(L, "marginRight") } _saveInitialAttribute(t, e) { const n = t.style[e]; n && r.default.setDataAttribute(t, e, n) } _resetElementAttributes(t, e) { const n = t => { const n = r.default.getDataAttribute(t, e); void 0 === n ? t.style.removeProperty(e) : (r.default.removeDataAttribute(t, e), t.style[e] = n) }; this._applyManipulationCallback(t, n) } _applyManipulationCallback(t, e) { g(t) ? e(t) : o.default.find(t, this._element).forEach(e) } isOverflowing() { return this.getWidth() > 0 } } const $ = { className: "modal-backdrop", isVisible: !0, isAnimated: !1, rootElement: "body", clickCallback: null }, N = { className: "string", isVisible: "boolean", isAnimated: "boolean", rootElement: "(element|string)", clickCallback: "(function|null)" }, D = "backdrop", S = "fade", I = "show", M = `mousedown.bs.${D}`; class P { constructor(t) { this._config = this._getConfig(t), this._isAppended = !1, this._element = null } show(t) { this._config.isVisible ? (this._append(), this._config.isAnimated && w(this._getElement()), this._getElement().classList.add(I), this._emulateAnimation((() => { O(t) }))) : O(t) } hide(t) { this._config.isVisible ? (this._getElement().classList.remove(I), this._emulateAnimation((() => { this.dispose(), O(t) }))) : O(t) } _getElement() { if (!this._element) { const t = document.createElement("div"); t.className = this._config.className, this._config.isAnimated && t.classList.add(S), this._element = t } return this._element } _getConfig(t) { return (t = { ...$, ..."object" == typeof t ? t : {} }).rootElement = _(t.rootElement), b(D, t, N), t } _append() { this._isAppended || (this._config.rootElement.append(this._getElement()), a.default.on(this._getElement(), M, (() => { O(this._config.clickCallback) })), this._isAppended = !0) } dispose() { this._isAppended && (a.default.off(this._element, M), this._element.remove(), this._isAppended = !1) } _emulateAnimation(t) { T(t, this._getElement(), this._config.isAnimated) } } const q = { trapElement: null, autofocus: !0 }, R = { trapElement: "element", autofocus: "boolean" }, W = "focustrap", H = ".bs.focustrap", B = `focusin${H}`, z = `keydown.tab${H}`, Q = "Tab", F = "forward", V = "backward"; class U { constructor(t) { this._config = this._getConfig(t), this._isActive = !1, this._lastTabNavDirection = null } activate() { const { trapElement: t, autofocus: e } = this._config; this._isActive || (e && t.focus(), a.default.off(document, H), a.default.on(document, B, (t => this._handleFocusin(t))), a.default.on(document, z, (t => this._handleKeydown(t))), this._isActive = !0) } deactivate() { this._isActive && (this._isActive = !1, a.default.off(document, H)) } _handleFocusin(t) { const { target: e } = t, { trapElement: n } = this._config; if (e === document || e === n || n.contains(e)) return; const i = o.default.focusableChildren(n); 0 === i.length ? n.focus() : this._lastTabNavDirection === V ? i[i.length - 1].focus() : i[0].focus() } _handleKeydown(t) { t.key === Q && (this._lastTabNavDirection = t.shiftKey ? V : F) } _getConfig(t) { return t = { ...q, ..."object" == typeof t ? t : {} }, b(W, t, R), t } } const K = (t, e = "hide") => { const n = `click.dismiss${t.EVENT_KEY}`, i = t.NAME; a.default.on(document, n, `[data-bs-dismiss="${i}"]`, (function (n) { if (["A", "AREA"].includes(this.tagName) && n.preventDefault(), y(this)) return; const s = h(this) || this.closest(`.${i}`); t.getOrCreateInstance(s)[e]() })) }, X = "offcanvas", Y = ".bs.offcanvas", G = ".data-api", Z = `load${Y}${G}`, J = "Escape", tt = { backdrop: !0, keyboard: !0, scroll: !1 }, et = { backdrop: "boolean", keyboard: "boolean", scroll: "boolean" }, nt = "show", it = "offcanvas-backdrop", st = ".offcanvas.show", ot = `show${Y}`, rt = `shown${Y}`, at = `hide${Y}`, lt = `hidden${Y}`, ct = `click${Y}${G}`, dt = `keydown.dismiss${Y}`, ut = '[data-bs-toggle="offcanvas"]'; class ft extends l.default { constructor(t, e) { super(t), this._config = this._getConfig(e), this._isShown = !1, this._backdrop = this._initializeBackDrop(), this._focustrap = this._initializeFocusTrap(), this._addEventListeners() } static get NAME() { return X } static get Default() { return tt } toggle(t) { return this._isShown ? this.hide() : this.show(t) } show(t) { if (this._isShown) return; if (a.default.trigger(this._element, ot, { relatedTarget: t }).defaultPrevented) return; this._isShown = !0, this._element.style.visibility = "visible", this._backdrop.show(), this._config.scroll || (new j).hide(), this._element.removeAttribute("aria-hidden"), this._element.setAttribute("aria-modal", !0), this._element.setAttribute("role", "dialog"), this._element.classList.add(nt); const e = () => { this._config.scroll || this._focustrap.activate(), a.default.trigger(this._element, rt, { relatedTarget: t }) }; this._queueCallback(e, this._element, !0) } hide() { if (!this._isShown) return; if (a.default.trigger(this._element, at).defaultPrevented) return; this._focustrap.deactivate(), this._element.blur(), this._isShown = !1, this._element.classList.remove(nt), this._backdrop.hide(); const t = () => { this._element.setAttribute("aria-hidden", !0), this._element.removeAttribute("aria-modal"), this._element.removeAttribute("role"), this._element.style.visibility = "hidden", this._config.scroll || (new j).reset(), a.default.trigger(this._element, lt) }; this._queueCallback(t, this._element, !0) } dispose() { this._backdrop.dispose(), this._focustrap.deactivate(), super.dispose() } _getConfig(t) { return t = { ...tt, ...r.default.getDataAttributes(this._element), ..."object" == typeof t ? t : {} }, b(X, t, et), t } _initializeBackDrop() { return new P({ className: it, isVisible: this._config.backdrop, isAnimated: !0, rootElement: this._element.parentNode, clickCallback: () => this.hide() }) } _initializeFocusTrap() { return new U({ trapElement: this._element }) } _addEventListeners() { a.default.on(this._element, dt, (t => { this._config.keyboard && t.key === J && this.hide() })) } static jQueryInterface(t) { return this.each((function () { const e = ft.getOrCreateInstance(this, t); if ("string" == typeof t) { if (void 0 === e[t] || t.startsWith("_") || "constructor" === t) throw new TypeError(`No method named "${t}"`); e[t](this) } })) } } return a.default.on(document, ct, ut, (function (t) { const e = h(this); if (["A", "AREA"].includes(this.tagName) && t.preventDefault(), y(this)) return; a.default.one(e, lt, (() => { v(this) && this.focus() })); const n = o.default.findOne(st); n && n !== e && ft.getInstance(n).hide(), ft.getOrCreateInstance(e).toggle(this) })), a.default.on(window, Z, (() => o.default.find(st).forEach((t => ft.getOrCreateInstance(t).show())))), K(ft), C(ft), ft }(m.exports, p.exports, a.exports, l.exports) }(te); var ee = te.exports, ne = { exports: {} }, ie = { exports: {} };
	/*!
		  * Bootstrap tooltip.js v5.1.3 (https://getbootstrap.com/)
		  * Copyright 2011-2021 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
		  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
		  */
	!function (t, e) { t.exports = function (t, e, n, i, s, o) { const r = t => t && "object" == typeof t && "default" in t ? t : { default: t }; function a(t) { if (t && t.__esModule) return t; const e = Object.create(null); if (t) for (const n in t) if ("default" !== n) { const i = Object.getOwnPropertyDescriptor(t, n); Object.defineProperty(e, n, i.get ? i : { enumerable: !0, get: () => t[n] }) } return e.default = t, Object.freeze(e) } const l = a(t), c = r(e), d = r(n), u = r(i), f = r(s), h = r(o), p = 1e6, m = t => null == t ? `${t}` : {}.toString.call(t).match(/\s([a-z]+)/i)[1].toLowerCase(), g = t => { do { t += Math.floor(Math.random() * p) } while (document.getElementById(t)); return t }, _ = t => !(!t || "object" != typeof t) && (void 0 !== t.jquery && (t = t[0]), void 0 !== t.nodeType), b = t => _(t) ? t.jquery ? t[0] : t : "string" == typeof t && t.length > 0 ? document.querySelector(t) : null, v = (t, e, n) => { Object.keys(n).forEach((i => { const s = n[i], o = e[i], r = o && _(o) ? "element" : m(o); if (!new RegExp(s).test(r)) throw new TypeError(`${t.toUpperCase()}: Option "${i}" provided type "${r}" but expected type "${s}".`) })) }, y = t => { if (!document.documentElement.attachShadow) return null; if ("function" == typeof t.getRootNode) { const e = t.getRootNode(); return e instanceof ShadowRoot ? e : null } return t instanceof ShadowRoot ? t : t.parentNode ? y(t.parentNode) : null }, w = () => { }, E = () => { const { jQuery: t } = window; return t && !document.body.hasAttribute("data-bs-no-jquery") ? t : null }, A = [], x = t => { "loading" === document.readyState ? (A.length || document.addEventListener("DOMContentLoaded", (() => { A.forEach((t => t())) })), A.push(t)) : t() }, C = () => "rtl" === document.documentElement.dir, O = t => { x((() => { const e = E(); if (e) { const n = t.NAME, i = e.fn[n]; e.fn[n] = t.jQueryInterface, e.fn[n].Constructor = t, e.fn[n].noConflict = () => (e.fn[n] = i, t.jQueryInterface) } })) }, T = new Set(["background", "cite", "href", "itemtype", "longdesc", "poster", "src", "xlink:href"]), k = /^(?:(?:https?|mailto|ftp|tel|file|sms):|[^#&/:?]*(?:[#/?]|$))/i, L = /^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[\d+/a-z]+=*$/i, j = (t, e) => { const n = t.nodeName.toLowerCase(); if (e.includes(n)) return !T.has(n) || Boolean(k.test(t.nodeValue) || L.test(t.nodeValue)); const i = e.filter((t => t instanceof RegExp)); for (let t = 0, e = i.length; t < e; t++)if (i[t].test(n)) return !0; return !1 }, $ = { "*": ["class", "dir", "id", "lang", "role", /^aria-[\w-]*$/i], a: ["target", "href", "title", "rel"], area: [], b: [], br: [], col: [], code: [], div: [], em: [], hr: [], h1: [], h2: [], h3: [], h4: [], h5: [], h6: [], i: [], img: ["src", "srcset", "alt", "title", "width", "height"], li: [], ol: [], p: [], pre: [], s: [], small: [], span: [], sub: [], sup: [], strong: [], u: [], ul: [] }; function N(t, e, n) { if (!t.length) return t; if (n && "function" == typeof n) return n(t); const i = (new window.DOMParser).parseFromString(t, "text/html"), s = [].concat(...i.body.querySelectorAll("*")); for (let t = 0, n = s.length; t < n; t++) { const n = s[t], i = n.nodeName.toLowerCase(); if (!Object.keys(e).includes(i)) { n.remove(); continue } const o = [].concat(...n.attributes), r = [].concat(e["*"] || [], e[i] || []); o.forEach((t => { j(t, r) || n.removeAttribute(t.nodeName) })) } return i.body.innerHTML } const D = "tooltip", S = ".bs.tooltip", I = "bs-tooltip", M = new Set(["sanitize", "allowList", "sanitizeFn"]), P = { animation: "boolean", template: "string", title: "(string|element|function)", trigger: "string", delay: "(number|object)", html: "boolean", selector: "(string|boolean)", placement: "(string|function)", offset: "(array|string|function)", container: "(string|element|boolean)", fallbackPlacements: "array", boundary: "(string|element)", customClass: "(string|function)", sanitize: "boolean", sanitizeFn: "(null|function)", allowList: "object", popperConfig: "(null|object|function)" }, q = { AUTO: "auto", TOP: "top", RIGHT: C() ? "left" : "right", BOTTOM: "bottom", LEFT: C() ? "right" : "left" }, R = { animation: !0, template: '<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>', trigger: "hover focus", title: "", delay: 0, html: !1, selector: !1, placement: "top", offset: [0, 0], container: !1, fallbackPlacements: ["top", "right", "bottom", "left"], boundary: "clippingParents", customClass: "", sanitize: !0, sanitizeFn: null, allowList: $, popperConfig: null }, W = { HIDE: `hide${S}`, HIDDEN: `hidden${S}`, SHOW: `show${S}`, SHOWN: `shown${S}`, INSERTED: `inserted${S}`, CLICK: `click${S}`, FOCUSIN: `focusin${S}`, FOCUSOUT: `focusout${S}`, MOUSEENTER: `mouseenter${S}`, MOUSELEAVE: `mouseleave${S}` }, H = "fade", B = "show", z = "show", Q = "out", F = ".tooltip-inner", V = ".modal", U = "hide.bs.modal", K = "hover", X = "focus", Y = "click", G = "manual"; class Z extends h.default { constructor(t, e) { if (void 0 === l) throw new TypeError("Bootstrap's tooltips require Popper (https://popper.js.org)"); super(t), this._isEnabled = !0, this._timeout = 0, this._hoverState = "", this._activeTrigger = {}, this._popper = null, this._config = this._getConfig(e), this.tip = null, this._setListeners() } static get Default() { return R } static get NAME() { return D } static get Event() { return W } static get DefaultType() { return P } enable() { this._isEnabled = !0 } disable() { this._isEnabled = !1 } toggleEnabled() { this._isEnabled = !this._isEnabled } toggle(t) { if (this._isEnabled) if (t) { const e = this._initializeOnDelegatedTarget(t); e._activeTrigger.click = !e._activeTrigger.click, e._isWithActiveTrigger() ? e._enter(null, e) : e._leave(null, e) } else { if (this.getTipElement().classList.contains(B)) return void this._leave(null, this); this._enter(null, this) } } dispose() { clearTimeout(this._timeout), d.default.off(this._element.closest(V), U, this._hideModalHandler), this.tip && this.tip.remove(), this._disposePopper(), super.dispose() } show() { if ("none" === this._element.style.display) throw new Error("Please use show on visible elements"); if (!this.isWithContent() || !this._isEnabled) return; const t = d.default.trigger(this._element, this.constructor.Event.SHOW), e = y(this._element), n = null === e ? this._element.ownerDocument.documentElement.contains(this._element) : e.contains(this._element); if (t.defaultPrevented || !n) return; "tooltip" === this.constructor.NAME && this.tip && this.getTitle() !== this.tip.querySelector(F).innerHTML && (this._disposePopper(), this.tip.remove(), this.tip = null); const i = this.getTipElement(), s = g(this.constructor.NAME); i.setAttribute("id", s), this._element.setAttribute("aria-describedby", s), this._config.animation && i.classList.add(H); const o = "function" == typeof this._config.placement ? this._config.placement.call(this, i, this._element) : this._config.placement, r = this._getAttachment(o); this._addAttachmentClass(r); const { container: a } = this._config; c.default.set(i, this.constructor.DATA_KEY, this), this._element.ownerDocument.documentElement.contains(this.tip) || (a.append(i), d.default.trigger(this._element, this.constructor.Event.INSERTED)), this._popper ? this._popper.update() : this._popper = l.createPopper(this._element, i, this._getPopperConfig(r)), i.classList.add(B); const u = this._resolvePossibleFunction(this._config.customClass); u && i.classList.add(...u.split(" ")), "ontouchstart" in document.documentElement && [].concat(...document.body.children).forEach((t => { d.default.on(t, "mouseover", w) })); const f = () => { const t = this._hoverState; this._hoverState = null, d.default.trigger(this._element, this.constructor.Event.SHOWN), t === Q && this._leave(null, this) }, h = this.tip.classList.contains(H); this._queueCallback(f, this.tip, h) } hide() { if (!this._popper) return; const t = this.getTipElement(), e = () => { this._isWithActiveTrigger() || (this._hoverState !== z && t.remove(), this._cleanTipClass(), this._element.removeAttribute("aria-describedby"), d.default.trigger(this._element, this.constructor.Event.HIDDEN), this._disposePopper()) }; if (d.default.trigger(this._element, this.constructor.Event.HIDE).defaultPrevented) return; t.classList.remove(B), "ontouchstart" in document.documentElement && [].concat(...document.body.children).forEach((t => d.default.off(t, "mouseover", w))), this._activeTrigger[Y] = !1, this._activeTrigger[X] = !1, this._activeTrigger[K] = !1; const n = this.tip.classList.contains(H); this._queueCallback(e, this.tip, n), this._hoverState = "" } update() { null !== this._popper && this._popper.update() } isWithContent() { return Boolean(this.getTitle()) } getTipElement() { if (this.tip) return this.tip; const t = document.createElement("div"); t.innerHTML = this._config.template; const e = t.children[0]; return this.setContent(e), e.classList.remove(H, B), this.tip = e, this.tip } setContent(t) { this._sanitizeAndSetContent(t, this.getTitle(), F) } _sanitizeAndSetContent(t, e, n) { const i = f.default.findOne(n, t); e || !i ? this.setElementContent(i, e) : i.remove() } setElementContent(t, e) { if (null !== t) return _(e) ? (e = b(e), void (this._config.html ? e.parentNode !== t && (t.innerHTML = "", t.append(e)) : t.textContent = e.textContent)) : void (this._config.html ? (this._config.sanitize && (e = N(e, this._config.allowList, this._config.sanitizeFn)), t.innerHTML = e) : t.textContent = e) } getTitle() { const t = this._element.getAttribute("data-bs-original-title") || this._config.title; return this._resolvePossibleFunction(t) } updateAttachment(t) { return "right" === t ? "end" : "left" === t ? "start" : t } _initializeOnDelegatedTarget(t, e) { return e || this.constructor.getOrCreateInstance(t.delegateTarget, this._getDelegateConfig()) } _getOffset() { const { offset: t } = this._config; return "string" == typeof t ? t.split(",").map((t => Number.parseInt(t, 10))) : "function" == typeof t ? e => t(e, this._element) : t } _resolvePossibleFunction(t) { return "function" == typeof t ? t.call(this._element) : t } _getPopperConfig(t) { const e = { placement: t, modifiers: [{ name: "flip", options: { fallbackPlacements: this._config.fallbackPlacements } }, { name: "offset", options: { offset: this._getOffset() } }, { name: "preventOverflow", options: { boundary: this._config.boundary } }, { name: "arrow", options: { element: `.${this.constructor.NAME}-arrow` } }, { name: "onChange", enabled: !0, phase: "afterWrite", fn: t => this._handlePopperPlacementChange(t) }], onFirstUpdate: t => { t.options.placement !== t.placement && this._handlePopperPlacementChange(t) } }; return { ...e, ..."function" == typeof this._config.popperConfig ? this._config.popperConfig(e) : this._config.popperConfig } } _addAttachmentClass(t) { this.getTipElement().classList.add(`${this._getBasicClassPrefix()}-${this.updateAttachment(t)}`) } _getAttachment(t) { return q[t.toUpperCase()] } _setListeners() { this._config.trigger.split(" ").forEach((t => { if ("click" === t) d.default.on(this._element, this.constructor.Event.CLICK, this._config.selector, (t => this.toggle(t))); else if (t !== G) { const e = t === K ? this.constructor.Event.MOUSEENTER : this.constructor.Event.FOCUSIN, n = t === K ? this.constructor.Event.MOUSELEAVE : this.constructor.Event.FOCUSOUT; d.default.on(this._element, e, this._config.selector, (t => this._enter(t))), d.default.on(this._element, n, this._config.selector, (t => this._leave(t))) } })), this._hideModalHandler = () => { this._element && this.hide() }, d.default.on(this._element.closest(V), U, this._hideModalHandler), this._config.selector ? this._config = { ...this._config, trigger: "manual", selector: "" } : this._fixTitle() } _fixTitle() { const t = this._element.getAttribute("title"), e = typeof this._element.getAttribute("data-bs-original-title"); (t || "string" !== e) && (this._element.setAttribute("data-bs-original-title", t || ""), !t || this._element.getAttribute("aria-label") || this._element.textContent || this._element.setAttribute("aria-label", t), this._element.setAttribute("title", "")) } _enter(t, e) { e = this._initializeOnDelegatedTarget(t, e), t && (e._activeTrigger["focusin" === t.type ? X : K] = !0), e.getTipElement().classList.contains(B) || e._hoverState === z ? e._hoverState = z : (clearTimeout(e._timeout), e._hoverState = z, e._config.delay && e._config.delay.show ? e._timeout = setTimeout((() => { e._hoverState === z && e.show() }), e._config.delay.show) : e.show()) } _leave(t, e) { e = this._initializeOnDelegatedTarget(t, e), t && (e._activeTrigger["focusout" === t.type ? X : K] = e._element.contains(t.relatedTarget)), e._isWithActiveTrigger() || (clearTimeout(e._timeout), e._hoverState = Q, e._config.delay && e._config.delay.hide ? e._timeout = setTimeout((() => { e._hoverState === Q && e.hide() }), e._config.delay.hide) : e.hide()) } _isWithActiveTrigger() { for (const t in this._activeTrigger) if (this._activeTrigger[t]) return !0; return !1 } _getConfig(t) { const e = u.default.getDataAttributes(this._element); return Object.keys(e).forEach((t => { M.has(t) && delete e[t] })), (t = { ...this.constructor.Default, ...e, ..."object" == typeof t && t ? t : {} }).container = !1 === t.container ? document.body : b(t.container), "number" == typeof t.delay && (t.delay = { show: t.delay, hide: t.delay }), "number" == typeof t.title && (t.title = t.title.toString()), "number" == typeof t.content && (t.content = t.content.toString()), v(D, t, this.constructor.DefaultType), t.sanitize && (t.template = N(t.template, t.allowList, t.sanitizeFn)), t } _getDelegateConfig() { const t = {}; for (const e in this._config) this.constructor.Default[e] !== this._config[e] && (t[e] = this._config[e]); return t } _cleanTipClass() { const t = this.getTipElement(), e = new RegExp(`(^|\\s)${this._getBasicClassPrefix()}\\S+`, "g"), n = t.getAttribute("class").match(e); null !== n && n.length > 0 && n.map((t => t.trim())).forEach((e => t.classList.remove(e))) } _getBasicClassPrefix() { return I } _handlePopperPlacementChange(t) { const { state: e } = t; e && (this.tip = e.elements.popper, this._cleanTipClass(), this._addAttachmentClass(this._getAttachment(e.placement))) } _disposePopper() { this._popper && (this._popper.destroy(), this._popper = null) } static jQueryInterface(t) { return this.each((function () { const e = Z.getOrCreateInstance(this, t); if ("string" == typeof t) { if (void 0 === e[t]) throw new TypeError(`No method named "${t}"`); e[t]() } })) } } return O(Z), Z }(Yt, c.exports, a.exports, p.exports, m.exports, l.exports) }(ie); var se = s(ie.exports);
/*!
	  * Bootstrap popover.js v5.1.3 (https://getbootstrap.com/)
	  * Copyright 2011-2021 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
	  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
	  */!function (t, e) { t.exports = function (t) { const e = (t => t && "object" == typeof t && "default" in t ? t : { default: t })(t), n = () => { const { jQuery: t } = window; return t && !document.body.hasAttribute("data-bs-no-jquery") ? t : null }, i = [], s = t => { "loading" === document.readyState ? (i.length || document.addEventListener("DOMContentLoaded", (() => { i.forEach((t => t())) })), i.push(t)) : t() }, o = t => { s((() => { const e = n(); if (e) { const n = t.NAME, i = e.fn[n]; e.fn[n] = t.jQueryInterface, e.fn[n].Constructor = t, e.fn[n].noConflict = () => (e.fn[n] = i, t.jQueryInterface) } })) }, r = "popover", a = ".bs.popover", l = "bs-popover", c = { ...e.default.Default, placement: "right", offset: [0, 8], trigger: "click", content: "", template: '<div class="popover" role="tooltip"><div class="popover-arrow"></div><h3 class="popover-header"></h3><div class="popover-body"></div></div>' }, d = { ...e.default.DefaultType, content: "(string|element|function)" }, u = { HIDE: `hide${a}`, HIDDEN: `hidden${a}`, SHOW: `show${a}`, SHOWN: `shown${a}`, INSERTED: `inserted${a}`, CLICK: `click${a}`, FOCUSIN: `focusin${a}`, FOCUSOUT: `focusout${a}`, MOUSEENTER: `mouseenter${a}`, MOUSELEAVE: `mouseleave${a}` }, f = ".popover-header", h = ".popover-body"; class p extends e.default { static get Default() { return c } static get NAME() { return r } static get Event() { return u } static get DefaultType() { return d } isWithContent() { return this.getTitle() || this._getContent() } setContent(t) { this._sanitizeAndSetContent(t, this.getTitle(), f), this._sanitizeAndSetContent(t, this._getContent(), h) } _getContent() { return this._resolvePossibleFunction(this._config.content) } _getBasicClassPrefix() { return l } static jQueryInterface(t) { return this.each((function () { const e = p.getOrCreateInstance(this, t); if ("string" == typeof t) { if (void 0 === e[t]) throw new TypeError(`No method named "${t}"`); e[t]() } })) } } return o(p), p }(ie.exports) }(ne); var oe = ne.exports, re = { exports: {} };
	/*!
		  * Bootstrap scrollspy.js v5.1.3 (https://getbootstrap.com/)
		  * Copyright 2011-2021 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
		  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
		  */
	!function (t, e) { t.exports = function (t, e, n, i) { const s = t => t && "object" == typeof t && "default" in t ? t : { default: t }, o = s(t), r = s(e), a = s(n), l = s(i), c = t => null == t ? `${t}` : {}.toString.call(t).match(/\s([a-z]+)/i)[1].toLowerCase(), d = t => { let e = t.getAttribute("data-bs-target"); if (!e || "#" === e) { let n = t.getAttribute("href"); if (!n || !n.includes("#") && !n.startsWith(".")) return null; n.includes("#") && !n.startsWith("#") && (n = `#${n.split("#")[1]}`), e = n && "#" !== n ? n.trim() : null } return e }, u = t => { const e = d(t); return e && document.querySelector(e) ? e : null }, f = t => !(!t || "object" != typeof t) && (void 0 !== t.jquery && (t = t[0]), void 0 !== t.nodeType), h = t => f(t) ? t.jquery ? t[0] : t : "string" == typeof t && t.length > 0 ? document.querySelector(t) : null, p = (t, e, n) => { Object.keys(n).forEach((i => { const s = n[i], o = e[i], r = o && f(o) ? "element" : c(o); if (!new RegExp(s).test(r)) throw new TypeError(`${t.toUpperCase()}: Option "${i}" provided type "${r}" but expected type "${s}".`) })) }, m = () => { const { jQuery: t } = window; return t && !document.body.hasAttribute("data-bs-no-jquery") ? t : null }, g = [], _ = t => { "loading" === document.readyState ? (g.length || document.addEventListener("DOMContentLoaded", (() => { g.forEach((t => t())) })), g.push(t)) : t() }, b = t => { _((() => { const e = m(); if (e) { const n = t.NAME, i = e.fn[n]; e.fn[n] = t.jQueryInterface, e.fn[n].Constructor = t, e.fn[n].noConflict = () => (e.fn[n] = i, t.jQueryInterface) } })) }, v = "scrollspy", y = ".bs.scrollspy", w = { offset: 10, method: "auto", target: "" }, E = { offset: "number", method: "string", target: "(string|element)" }, A = `activate${y}`, x = `scroll${y}`, C = `load${y}.data-api`, O = "dropdown-item", T = "active", k = '[data-bs-spy="scroll"]', L = ".nav, .list-group", j = ".nav-link", $ = ".nav-item", N = ".list-group-item", D = `${j}, ${N}, .${O}`, S = ".dropdown", I = ".dropdown-toggle", M = "offset", P = "position"; class q extends l.default { constructor(t, e) { super(t), this._scrollElement = "BODY" === this._element.tagName ? window : this._element, this._config = this._getConfig(e), this._offsets = [], this._targets = [], this._activeTarget = null, this._scrollHeight = 0, o.default.on(this._scrollElement, x, (() => this._process())), this.refresh(), this._process() } static get Default() { return w } static get NAME() { return v } refresh() { const t = this._scrollElement === this._scrollElement.window ? M : P, e = "auto" === this._config.method ? t : this._config.method, n = e === P ? this._getScrollTop() : 0; this._offsets = [], this._targets = [], this._scrollHeight = this._getScrollHeight(), a.default.find(D, this._config.target).map((t => { const i = u(t), s = i ? a.default.findOne(i) : null; if (s) { const t = s.getBoundingClientRect(); if (t.width || t.height) return [r.default[e](s).top + n, i] } return null })).filter((t => t)).sort(((t, e) => t[0] - e[0])).forEach((t => { this._offsets.push(t[0]), this._targets.push(t[1]) })) } dispose() { o.default.off(this._scrollElement, y), super.dispose() } _getConfig(t) { return (t = { ...w, ...r.default.getDataAttributes(this._element), ..."object" == typeof t && t ? t : {} }).target = h(t.target) || document.documentElement, p(v, t, E), t } _getScrollTop() { return this._scrollElement === window ? this._scrollElement.pageYOffset : this._scrollElement.scrollTop } _getScrollHeight() { return this._scrollElement.scrollHeight || Math.max(document.body.scrollHeight, document.documentElement.scrollHeight) } _getOffsetHeight() { return this._scrollElement === window ? window.innerHeight : this._scrollElement.getBoundingClientRect().height } _process() { const t = this._getScrollTop() + this._config.offset, e = this._getScrollHeight(), n = this._config.offset + e - this._getOffsetHeight(); if (this._scrollHeight !== e && this.refresh(), t >= n) { const t = this._targets[this._targets.length - 1]; this._activeTarget !== t && this._activate(t) } else { if (this._activeTarget && t < this._offsets[0] && this._offsets[0] > 0) return this._activeTarget = null, void this._clear(); for (let e = this._offsets.length; e--;)this._activeTarget !== this._targets[e] && t >= this._offsets[e] && (void 0 === this._offsets[e + 1] || t < this._offsets[e + 1]) && this._activate(this._targets[e]) } } _activate(t) { this._activeTarget = t, this._clear(); const e = D.split(",").map((e => `${e}[data-bs-target="${t}"],${e}[href="${t}"]`)), n = a.default.findOne(e.join(","), this._config.target); n.classList.add(T), n.classList.contains(O) ? a.default.findOne(I, n.closest(S)).classList.add(T) : a.default.parents(n, L).forEach((t => { a.default.prev(t, `${j}, ${N}`).forEach((t => t.classList.add(T))), a.default.prev(t, $).forEach((t => { a.default.children(t, j).forEach((t => t.classList.add(T))) })) })), o.default.trigger(this._scrollElement, A, { relatedTarget: t }) } _clear() { a.default.find(D, this._config.target).filter((t => t.classList.contains(T))).forEach((t => t.classList.remove(T))) } static jQueryInterface(t) { return this.each((function () { const e = q.getOrCreateInstance(this, t); if ("string" == typeof t) { if (void 0 === e[t]) throw new TypeError(`No method named "${t}"`); e[t]() } })) } } return o.default.on(window, C, (() => { a.default.find(k).forEach((t => new q(t))) })), b(q), q }(a.exports, p.exports, m.exports, l.exports) }(re); var ae = re.exports, le = { exports: {} };
	/*!
		  * Bootstrap tab.js v5.1.3 (https://getbootstrap.com/)
		  * Copyright 2011-2021 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
		  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
		  */
	!function (t, e) { t.exports = function (t, e, n) { const i = t => t && "object" == typeof t && "default" in t ? t : { default: t }, s = i(t), o = i(e), r = i(n), a = t => { let e = t.getAttribute("data-bs-target"); if (!e || "#" === e) { let n = t.getAttribute("href"); if (!n || !n.includes("#") && !n.startsWith(".")) return null; n.includes("#") && !n.startsWith("#") && (n = `#${n.split("#")[1]}`), e = n && "#" !== n ? n.trim() : null } return e }, l = t => { const e = a(t); return e ? document.querySelector(e) : null }, c = t => !t || t.nodeType !== Node.ELEMENT_NODE || !!t.classList.contains("disabled") || (void 0 !== t.disabled ? t.disabled : t.hasAttribute("disabled") && "false" !== t.getAttribute("disabled")), d = t => { t.offsetHeight }, u = () => { const { jQuery: t } = window; return t && !document.body.hasAttribute("data-bs-no-jquery") ? t : null }, f = [], h = t => { "loading" === document.readyState ? (f.length || document.addEventListener("DOMContentLoaded", (() => { f.forEach((t => t())) })), f.push(t)) : t() }, p = t => { h((() => { const e = u(); if (e) { const n = t.NAME, i = e.fn[n]; e.fn[n] = t.jQueryInterface, e.fn[n].Constructor = t, e.fn[n].noConflict = () => (e.fn[n] = i, t.jQueryInterface) } })) }, m = "tab", g = ".bs.tab", _ = `hide${g}`, b = `hidden${g}`, v = `show${g}`, y = `shown${g}`, w = `click${g}.data-api`, E = "dropdown-menu", A = "active", x = "fade", C = "show", O = ".dropdown", T = ".nav, .list-group", k = ".active", L = ":scope > li > .active", j = '[data-bs-toggle="tab"], [data-bs-toggle="pill"], [data-bs-toggle="list"]', $ = ".dropdown-toggle", N = ":scope > .dropdown-menu .active"; class D extends r.default { static get NAME() { return m } show() { if (this._element.parentNode && this._element.parentNode.nodeType === Node.ELEMENT_NODE && this._element.classList.contains(A)) return; let t; const e = l(this._element), n = this._element.closest(T); if (n) { const e = "UL" === n.nodeName || "OL" === n.nodeName ? L : k; t = o.default.find(e, n), t = t[t.length - 1] } const i = t ? s.default.trigger(t, _, { relatedTarget: this._element }) : null; if (s.default.trigger(this._element, v, { relatedTarget: t }).defaultPrevented || null !== i && i.defaultPrevented) return; this._activate(this._element, n); const r = () => { s.default.trigger(t, b, { relatedTarget: this._element }), s.default.trigger(this._element, y, { relatedTarget: t }) }; e ? this._activate(e, e.parentNode, r) : r() } _activate(t, e, n) { const i = (!e || "UL" !== e.nodeName && "OL" !== e.nodeName ? o.default.children(e, k) : o.default.find(L, e))[0], s = n && i && i.classList.contains(x), r = () => this._transitionComplete(t, i, n); i && s ? (i.classList.remove(C), this._queueCallback(r, t, !0)) : r() } _transitionComplete(t, e, n) { if (e) { e.classList.remove(A); const t = o.default.findOne(N, e.parentNode); t && t.classList.remove(A), "tab" === e.getAttribute("role") && e.setAttribute("aria-selected", !1) } t.classList.add(A), "tab" === t.getAttribute("role") && t.setAttribute("aria-selected", !0), d(t), t.classList.contains(x) && t.classList.add(C); let i = t.parentNode; if (i && "LI" === i.nodeName && (i = i.parentNode), i && i.classList.contains(E)) { const e = t.closest(O); e && o.default.find($, e).forEach((t => t.classList.add(A))), t.setAttribute("aria-expanded", !0) } n && n() } static jQueryInterface(t) { return this.each((function () { const e = D.getOrCreateInstance(this); if ("string" == typeof t) { if (void 0 === e[t]) throw new TypeError(`No method named "${t}"`); e[t]() } })) } } return s.default.on(document, w, j, (function (t) { ["A", "AREA"].includes(this.tagName) && t.preventDefault(), c(this) || D.getOrCreateInstance(this).show() })), p(D), D }(a.exports, m.exports, l.exports) }(le); var ce = le.exports, de = { exports: {} };
	/*!
		  * Bootstrap toast.js v5.1.3 (https://getbootstrap.com/)
		  * Copyright 2011-2021 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
		  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
		  */
	!function (t, e) { t.exports = function (t, e, n) { const i = t => t && "object" == typeof t && "default" in t ? t : { default: t }, s = i(t), o = i(e), r = i(n), a = t => null == t ? `${t}` : {}.toString.call(t).match(/\s([a-z]+)/i)[1].toLowerCase(), l = t => { let e = t.getAttribute("data-bs-target"); if (!e || "#" === e) { let n = t.getAttribute("href"); if (!n || !n.includes("#") && !n.startsWith(".")) return null; n.includes("#") && !n.startsWith("#") && (n = `#${n.split("#")[1]}`), e = n && "#" !== n ? n.trim() : null } return e }, c = t => { const e = l(t); return e ? document.querySelector(e) : null }, d = t => !(!t || "object" != typeof t) && (void 0 !== t.jquery && (t = t[0]), void 0 !== t.nodeType), u = (t, e, n) => { Object.keys(n).forEach((i => { const s = n[i], o = e[i], r = o && d(o) ? "element" : a(o); if (!new RegExp(s).test(r)) throw new TypeError(`${t.toUpperCase()}: Option "${i}" provided type "${r}" but expected type "${s}".`) })) }, f = t => !t || t.nodeType !== Node.ELEMENT_NODE || !!t.classList.contains("disabled") || (void 0 !== t.disabled ? t.disabled : t.hasAttribute("disabled") && "false" !== t.getAttribute("disabled")), h = t => { t.offsetHeight }, p = () => { const { jQuery: t } = window; return t && !document.body.hasAttribute("data-bs-no-jquery") ? t : null }, m = [], g = t => { "loading" === document.readyState ? (m.length || document.addEventListener("DOMContentLoaded", (() => { m.forEach((t => t())) })), m.push(t)) : t() }, _ = t => { g((() => { const e = p(); if (e) { const n = t.NAME, i = e.fn[n]; e.fn[n] = t.jQueryInterface, e.fn[n].Constructor = t, e.fn[n].noConflict = () => (e.fn[n] = i, t.jQueryInterface) } })) }, b = (t, e = "hide") => { const n = `click.dismiss${t.EVENT_KEY}`, i = t.NAME; s.default.on(document, n, `[data-bs-dismiss="${i}"]`, (function (n) { if (["A", "AREA"].includes(this.tagName) && n.preventDefault(), f(this)) return; const s = c(this) || this.closest(`.${i}`); t.getOrCreateInstance(s)[e]() })) }, v = "toast", y = ".bs.toast", w = `mouseover${y}`, E = `mouseout${y}`, A = `focusin${y}`, x = `focusout${y}`, C = `hide${y}`, O = `hidden${y}`, T = `show${y}`, k = `shown${y}`, L = "fade", j = "hide", $ = "show", N = "showing", D = { animation: "boolean", autohide: "boolean", delay: "number" }, S = { animation: !0, autohide: !0, delay: 5e3 }; class I extends r.default { constructor(t, e) { super(t), this._config = this._getConfig(e), this._timeout = null, this._hasMouseInteraction = !1, this._hasKeyboardInteraction = !1, this._setListeners() } static get DefaultType() { return D } static get Default() { return S } static get NAME() { return v } show() { if (s.default.trigger(this._element, T).defaultPrevented) return; this._clearTimeout(), this._config.animation && this._element.classList.add(L); const t = () => { this._element.classList.remove(N), s.default.trigger(this._element, k), this._maybeScheduleHide() }; this._element.classList.remove(j), h(this._element), this._element.classList.add($), this._element.classList.add(N), this._queueCallback(t, this._element, this._config.animation) } hide() { if (!this._element.classList.contains($)) return; if (s.default.trigger(this._element, C).defaultPrevented) return; const t = () => { this._element.classList.add(j), this._element.classList.remove(N), this._element.classList.remove($), s.default.trigger(this._element, O) }; this._element.classList.add(N), this._queueCallback(t, this._element, this._config.animation) } dispose() { this._clearTimeout(), this._element.classList.contains($) && this._element.classList.remove($), super.dispose() } _getConfig(t) { return t = { ...S, ...o.default.getDataAttributes(this._element), ..."object" == typeof t && t ? t : {} }, u(v, t, this.constructor.DefaultType), t } _maybeScheduleHide() { this._config.autohide && (this._hasMouseInteraction || this._hasKeyboardInteraction || (this._timeout = setTimeout((() => { this.hide() }), this._config.delay))) } _onInteraction(t, e) { switch (t.type) { case "mouseover": case "mouseout": this._hasMouseInteraction = e; break; case "focusin": case "focusout": this._hasKeyboardInteraction = e }if (e) return void this._clearTimeout(); const n = t.relatedTarget; this._element === n || this._element.contains(n) || this._maybeScheduleHide() } _setListeners() { s.default.on(this._element, w, (t => this._onInteraction(t, !0))), s.default.on(this._element, E, (t => this._onInteraction(t, !1))), s.default.on(this._element, A, (t => this._onInteraction(t, !0))), s.default.on(this._element, x, (t => this._onInteraction(t, !1))) } _clearTimeout() { clearTimeout(this._timeout), this._timeout = null } static jQueryInterface(t) { return this.each((function () { const e = I.getOrCreateInstance(this, t); if ("string" == typeof t) { if (void 0 === e[t]) throw new TypeError(`No method named "${t}"`); e[t](this) } })) } } return b(I), _(I), I }(a.exports, p.exports, l.exports) }(de); var ue, fe, he, pe = de.exports; ue = navigator.userAgent.toLowerCase().indexOf("webkit") > -1, fe = navigator.userAgent.toLowerCase().indexOf("opera") > -1, he = navigator.userAgent.toLowerCase().indexOf("msie") > -1, (ue || fe || he) && document.getElementById && window.addEventListener && window.addEventListener("hashchange", (function () { var t, e = location.hash.substring(1); /^[A-z0-9_-]+$/.test(e) && (t = document.getElementById(e)) && (/^(?:a|select|input|button|textarea)$/i.test(t.tagName) || (t.tabIndex = -1), t.focus()) }), !1); new class { constructor() { this.events() } events() { i.default("#my-notes").on("click", ".delete-note", this.deleteNote), i.default("#my-notes").on("click", ".edit-note", this.editNote.bind(this)), i.default("#my-notes").on("click", ".update-note", this.updateNote.bind(this)), i.default(".submit-note").on("click", this.createNote.bind(this)) } editNote(t) { var e = i.default(t.target).parents("li"); "editable" == e.data("state") ? this.makeNoteReadOnly(e) : this.makeNoteEditable(e) } makeNoteEditable(t) { t.find(".edit-note").html('<i class="fa fa-times" aria-hidden="true"></i> Cancel'), t.find(".note-title-field, .note-body-field").removeAttr("readonly").addClass("note-active-field"), t.find(".update-note").addClass("update-note--visible"), t.data("state", "editable") } makeNoteReadOnly(t) { t.find(".edit-note").html('<i class="fa fa-pencil" aria-hidden="true"></i> Edit'), t.find(".note-title-field, .note-body-field").attr("readonly", "readonly").removeClass("note-active-field"), t.find(".update-note").removeClass("update-note--visible"), t.data("state", "cancel") } deleteNote(t) { var e = i.default(t.target).parents("li"); i.default.ajax({ beforeSend: t => { t.setRequestHeader("X-WP-Nonce", globalData.nonce) }, url: globalData.root_url + "/wp-json/wp/v2/note/" + e.data("id"), type: "DELETE", success: t => { e.slideUp(), console.log("Congrats"), console.log(t) }, error: t => { console.log("Sorry"), console.log(t) } }) } updateNote(t) { var e = i.default(t.target).parents("li"), n = { title: e.find(".note-title-field").val(), content: e.find(".note-body-field").val() }; i.default.ajax({ beforeSend: t => { t.setRequestHeader("X-WP-Nonce", globalData.nonce) }, url: globalData.root_url + "/wp-json/wp/v2/note/" + e.data("id"), type: "POST", data: n, success: t => { this.makeNoteReadOnly(e), console.log("Congrats"), console.log(t) }, error: t => { console.log("Sorry"), console.log(t) } }) } createNote(t) { let e = i.default("#my-notes li").length; var n = { title: i.default(".new-note-title").val(), status: "publish" }; i.default(".new-note-title").val() ? (i.default(".note_users-message").hide(), i.default.ajax({ beforeSend: t => { t.setRequestHeader("X-WP-Nonce", globalData.nonce) }, url: globalData.root_url + "/wp-json/wp/v2/note/", type: "POST", data: n, success: t => { i.default(".new-note-title, .new-note-body").val(""), i.default(`\n                    <li data-id="${t.id}"><i class="fa fa-check-square"\n                    aria-hidden="true"></i>${t.title.raw}</li>\n                      \n          `).prependTo("#my-notes").hide().slideDown(), console.log("Congrats"), console.log(t), e >= 5 && i.default("#my-notes li:last-child").hide() }, error: t => { console.log("Sorry"), console.log(t) } })) : i.default(".note_users-message").show() } }, new class { constructor() { this.events() } events() { i.default(".like-box").on("click", this.ourClickDispatcher.bind(this)) } ourClickDispatcher(t) { var e = i.default(t.target).closest(".like-box"); "yes" == e.attr("data-exists") ? this.deleteLike(e) : this.createLike(e) } createLike(t) { i.default.ajax({ beforeSend: t => { t.setRequestHeader("X-WP-Nonce", globalData.nonce) }, url: globalData.root_url + "/wp-json/university/v1/manageLike", type: "POST", data: { professorId: t.data("professor") }, success: e => { t.attr("data-exists", "yes"); var n = parseInt(t.find(".like-count").html(), 10); n++, t.find(".like-count").html(n), t.attr("data-like", e), console.log(e) }, error: t => { console.log(t) } }) } deleteLike(t) { i.default.ajax({ beforeSend: t => { t.setRequestHeader("X-WP-Nonce", globalData.nonce) }, url: globalData.root_url + "/wp-json/university/v1/manageLike", data: { like: t.attr("data-like") }, type: "DELETE", success: e => { t.attr("data-exists", "no"); var n = parseInt(t.find(".like-count").html(), 10); n--, t.find(".like-count").html(n), t.attr("data-like", ""), console.log(e) }, error: t => { console.log(t) } }) } }, function (t) { t(document).ready((function () { t("ul.nav li.dropdown").hover((function () { t(".dropdown-menu", this).fadeIn() }), (function () { t(".dropdown-menu", this).fadeOut("fast") })), t(".section-third h4.second").on("click", (function (e) { e.preventDefault(); var n = t(this).data("toggle"); t("div.toggle").hide("slow"), t(n).show("slow") })) })) }(jQuery), t.Alert = d, t.Button = f, t.Carousel = g, t.Collapse = b, t.Dropdown = Gt, t.Modal = Jt, t.Offcanvas = ee, t.Popover = oe, t.Scrollspy = ae, t.Tab = ce, t.Toast = pe, t.Tooltip = se, Object.defineProperty(t, "__esModule", { value: !0 })
}));
//# sourceMappingURL=theme.min.js.map